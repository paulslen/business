"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.getTransaction = exports.getRawArbTransactionReceipt = void 0;
const providers_1 = require("@ethersproject/providers");
const arbTransaction_1 = require("../dataEntities/arbTransaction");
const ethers_1 = require("ethers");
const __1 = require("../..");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const SequencerInbox__factory_1 = require("../abi/factories/SequencerInbox__factory");
const eventFetcher_1 = require("./eventFetcher");
class ArbFormatter extends providers_1.Formatter {
    getDefaultFormats() {
        // formats was already initialised in super, so we can just access here
        const superFormats = super.getDefaultFormats();
        const address = this.address.bind(this);
        const bigNumber = this.bigNumber.bind(this);
        const data = this.data.bind(this);
        const hash = this.hash.bind(this);
        const number = this.number.bind(this);
        const feeStats = this.feeStats.bind(this);
        const feeStatComponents = this.feeStatComponents.bind(this);
        const batchInfo = this.batchInfo.bind(this);
        const returnCode = this.returnCode.bind(this);
        const arbTransactionFormat = Object.assign(Object.assign({}, superFormats.transaction), { l1SequenceNumber: bigNumber, 
            // parentRequestId: hash,
            // indexInParent: number,
            // arbType: number,
            // arbSubType: number,
            l1BlockNumber: number });
        const arbReceiptFormat = Object.assign(Object.assign({}, superFormats.receipt), { returnData: providers_1.Formatter.allowNull(data), returnCode: returnCode, feeStats: feeStats, batchInfo: providers_1.Formatter.allowNull(batchInfo, null), l1BlockNumber: number });
        const feeStatsFormat = {
            prices: feeStatComponents,
            unitsUsed: feeStatComponents,
            paid: feeStatComponents,
        };
        const feeStatComponentsFormat = {
            l1Transaction: bigNumber,
            l1Calldata: bigNumber,
            l2Storage: bigNumber,
            l2Computation: bigNumber,
        };
        const batchInfoFormat = {
            confirmations: number,
            blockNumber: number,
            logAddress: address,
            logTopics: providers_1.Formatter.arrayOf(hash),
            logData: data,
        };
        return Object.assign(Object.assign({}, superFormats), { transaction: arbTransactionFormat, receipt: arbReceiptFormat, feeStats: feeStatsFormat, feeStatComponents: feeStatComponentsFormat, batchInfo: batchInfoFormat });
    }
    returnCode(value) {
        const bn = ethers_1.BigNumber.from(value);
        const returnNum = bn.toNumber();
        if (!Object.values(arbTransaction_1.ReturnCode).includes(returnNum)) {
            return ethers_1.logger.throwArgumentError('invalid return code', 'value', value);
        }
        return returnNum;
    }
    feeStatComponents(feeStatComponents) {
        return providers_1.Formatter.check(this.formats.feeStatComponents, feeStatComponents);
    }
    feeStats(feeStats) {
        return providers_1.Formatter.check(this.formats.feeStats, feeStats);
    }
    batchInfo(batchInfo) {
        return providers_1.Formatter.check(this.formats.batchInfo, batchInfo);
    }
    transactionResponse(transaction) {
        return super.transactionResponse(transaction);
    }
    receipt(value) {
        return super.receipt(value);
    }
}
/**
 * Get batch info for a message of a given sequence number
 * If eventType is "sequencer" only sequencer events will be looked for
 * If eventType is "delayed" only force included events will be looked for
 * @returns
 */
const getBatch = async (seqNum, l1Provider, l2Network, startBlock, endBlock, eventTypes) => {
    const batchEvents = new eventFetcher_1.EventFetcher(l1Provider);
    const events = await batchEvents.getEvents(l2Network.ethBridge.sequencerInbox, SequencerInbox__factory_1.SequencerInbox__factory, c => {
        const eventTopics = eventTypes === 'sequencer'
            ? [
                c.interface.getEventTopic(c.interface.getEvent('SequencerBatchDelivered')),
                c.interface.getEventTopic(c.interface.getEvent('SequencerBatchDeliveredFromOrigin')),
            ]
            : [
                c.interface.getEventTopic(c.interface.getEvent('DelayedInboxForced')),
            ];
        return { topics: [eventTopics] };
    }, { fromBlock: startBlock, toBlock: endBlock });
    // find the batch containing the seq number
    const batch = events.filter(b => b.event.firstMessageNum.lte(seqNum) && b.event.newMessageCount.gt(seqNum))[0];
    if (!batch)
        return null;
    return {
        blockNumber: batch.blockNumber,
        logAddress: batch.address,
        logData: batch.data,
        logTopics: batch.topics,
    };
};
/**
 * Get batch info for a message of a given sequence number
 * Only looks for events created by the sequencer
 * @param seqNum
 * @param l2Txl1BlockNumber The l1BlockNumber that was in the receipt of the l2 transaction. This is the value block.number would have during the execution of that transaciton.
 * @param l1Provider
 * @param l2Network
 * @returns
 */
const getSequencerBatch = async (seqNum, l2Txl1BlockNumber, l1Provider, l2Network) => {
    const inbox = SequencerInbox__factory_1.SequencerInbox__factory.connect(l2Network.ethBridge.sequencerInbox, l1Provider);
    const delayBlocks = (await inbox.maxDelayBlocks()).toNumber();
    const startBlock = l2Txl1BlockNumber;
    const delayedBlockMax = l2Txl1BlockNumber + delayBlocks;
    const currentBlock = await l1Provider.getBlockNumber();
    const endBlock = Math.min(delayedBlockMax, currentBlock);
    return await getBatch(seqNum, l1Provider, l2Network, startBlock, endBlock, 'sequencer');
};
/**
 * Get batch info for a message of a given sequence number
 * Only looks for force included events
 * @param seqNum
 * @param l2Txl1BlockNumber The l1BlockNumber that was in the receipt of the l2 transaction. This is the value block.number would have during the execution of that transaciton.
 * @param l1Provider
 * @param l2Network
 * @returns
 */
const getDelayedBatch = async (seqNum, l2Txl1BlockNumber, l1Provider, l2Network) => {
    const inbox = SequencerInbox__factory_1.SequencerInbox__factory.connect(l2Network.ethBridge.sequencerInbox, l1Provider);
    const delayBlocks = (await inbox.maxDelayBlocks()).toNumber();
    const delayedBlockMax = l2Txl1BlockNumber + delayBlocks;
    const currentBlock = await l1Provider.getBlockNumber();
    const startBlock = Math.min(delayedBlockMax, currentBlock);
    const endBlock = Math.max(startBlock, currentBlock);
    return await getBatch(seqNum, l1Provider, l2Network, startBlock, endBlock, 'delayed');
};
/**
 * Fetch a transaction receipt from an l2Provider
 * If an l1Provider is also provided then info about the l1 data
 * availability of the transaction will also be returned in the l1InboxBatchInfo
 * field
 * @param l2Provider
 * @param txHash
 * @param l1ProviderForBatch
 * @returns
 */
const getRawArbTransactionReceipt = async (l2Provider, txHash, l1ProviderForBatch) => {
    const rec = await l2Provider.send('eth_getTransactionReceipt', [txHash]);
    if (rec == null)
        return null;
    const arbFormatter = new ArbFormatter();
    const arbTxReceipt = arbFormatter.receipt(rec);
    // if we haven't already got batch info, and it has been requested
    // then we fetch it and append it
    if (!arbTxReceipt.l1InboxBatchInfo && l1ProviderForBatch) {
        const l2Network = await (0, __1.getL2Network)(l2Provider);
        const l1Network = await (0, __1.getL1Network)(l2Network.partnerChainID);
        signerOrProvider_1.SignerProviderUtils.checkNetworkMatches(l1ProviderForBatch, l1Network.chainID);
        const tx = await (0, exports.getTransaction)(l2Provider, txHash);
        if (tx) {
            const sequencerBatch = await getSequencerBatch(tx.l1SequenceNumber, tx.l1BlockNumber, l1ProviderForBatch, l2Network);
            let batch = sequencerBatch;
            // we didnt find a sequencer batch, either it hasnt been included
            // yet, or we it was included as a delayed batch
            if (!sequencerBatch) {
                const currentBlock = await l1ProviderForBatch.getBlockNumber();
                const inbox = SequencerInbox__factory_1.SequencerInbox__factory.connect(l2Network.ethBridge.sequencerInbox, l1ProviderForBatch);
                const delayBlocks = (await inbox.maxDelayBlocks()).toNumber();
                const delaySeconds = (await inbox.maxDelaySeconds()).toNumber();
                const l1Timestamp = (await l1ProviderForBatch.getBlock(tx.l1BlockNumber)).timestamp;
                const timeNowSec = Date.now() / 1000;
                if (currentBlock > delayBlocks + tx.l1BlockNumber &&
                    timeNowSec > delaySeconds + l1Timestamp) {
                    // we've passed the delayed block period, so it's
                    // worthwhile to look for delayed batches
                    batch = await getDelayedBatch(tx.l1SequenceNumber, tx.l1BlockNumber, l1ProviderForBatch, l2Network);
                }
            }
            const currentBlock = await l1ProviderForBatch.getBlockNumber();
            arbTxReceipt.l1InboxBatchInfo = batch
                ? Object.assign(Object.assign({}, batch), { confirmations: currentBlock - batch.blockNumber }) : null;
        }
    }
    return arbTxReceipt;
};
exports.getRawArbTransactionReceipt = getRawArbTransactionReceipt;
const getTransaction = async (l2Provider, txHash) => {
    const tx = await l2Provider.send('eth_getTransactionByHash', [txHash]);
    if (tx === null)
        return null;
    const arbFormatter = new ArbFormatter();
    return arbFormatter.transactionResponse(tx);
};
exports.getTransaction = getTransaction;
