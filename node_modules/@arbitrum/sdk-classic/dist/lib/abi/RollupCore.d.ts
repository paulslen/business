import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface RollupCoreInterface extends utils.Interface {
    contractName: "RollupCore";
    functions: {
        "_stakerMap(address)": FunctionFragment;
        "amountStaked(address)": FunctionFragment;
        "currentChallenge(address)": FunctionFragment;
        "firstUnresolvedNode()": FunctionFragment;
        "getNode(uint256)": FunctionFragment;
        "getNodeHash(uint256)": FunctionFragment;
        "getStakerAddress(uint256)": FunctionFragment;
        "isStaked(address)": FunctionFragment;
        "isZombie(address)": FunctionFragment;
        "lastStakeBlock()": FunctionFragment;
        "latestConfirmed()": FunctionFragment;
        "latestNodeCreated()": FunctionFragment;
        "latestStakedNode(address)": FunctionFragment;
        "stakerCount()": FunctionFragment;
        "withdrawableFunds(address)": FunctionFragment;
        "zombieAddress(uint256)": FunctionFragment;
        "zombieCount()": FunctionFragment;
        "zombieLatestStakedNode(uint256)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "_stakerMap", values: [string]): string;
    encodeFunctionData(functionFragment: "amountStaked", values: [string]): string;
    encodeFunctionData(functionFragment: "currentChallenge", values: [string]): string;
    encodeFunctionData(functionFragment: "firstUnresolvedNode", values?: undefined): string;
    encodeFunctionData(functionFragment: "getNode", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getNodeHash", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "getStakerAddress", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "isStaked", values: [string]): string;
    encodeFunctionData(functionFragment: "isZombie", values: [string]): string;
    encodeFunctionData(functionFragment: "lastStakeBlock", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestConfirmed", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestNodeCreated", values?: undefined): string;
    encodeFunctionData(functionFragment: "latestStakedNode", values: [string]): string;
    encodeFunctionData(functionFragment: "stakerCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "withdrawableFunds", values: [string]): string;
    encodeFunctionData(functionFragment: "zombieAddress", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "zombieCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "zombieLatestStakedNode", values: [BigNumberish]): string;
    decodeFunctionResult(functionFragment: "_stakerMap", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "amountStaked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "currentChallenge", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "firstUnresolvedNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getNodeHash", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getStakerAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isStaked", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isZombie", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "lastStakeBlock", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestConfirmed", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestNodeCreated", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "latestStakedNode", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "stakerCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "withdrawableFunds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieAddress", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "zombieLatestStakedNode", data: BytesLike): Result;
    events: {
        "NodeConfirmed(uint256,bytes32,uint256,bytes32,uint256)": EventFragment;
        "NodeCreated(uint256,bytes32,bytes32,bytes32,uint256,uint256,bytes32,bytes32[3][2],uint256[4][2])": EventFragment;
        "NodeRejected(uint256)": EventFragment;
        "RollupChallengeStarted(address,address,address,uint256)": EventFragment;
        "RollupCreated(bytes32)": EventFragment;
        "UserStakeUpdated(address,uint256,uint256)": EventFragment;
        "UserWithdrawableFundsUpdated(address,uint256,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "NodeConfirmed"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NodeCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "NodeRejected"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RollupChallengeStarted"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "RollupCreated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserStakeUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "UserWithdrawableFundsUpdated"): EventFragment;
}
export declare type NodeConfirmedEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    string,
    BigNumber
], {
    nodeNum: BigNumber;
    afterSendAcc: string;
    afterSendCount: BigNumber;
    afterLogAcc: string;
    afterLogCount: BigNumber;
}>;
export declare type NodeConfirmedEventFilter = TypedEventFilter<NodeConfirmedEvent>;
export declare type NodeCreatedEvent = TypedEvent<[
    BigNumber,
    string,
    string,
    string,
    BigNumber,
    BigNumber,
    string,
    [
        [string, string, string],
        [string, string, string]
    ],
    [
        [
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ],
        [
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ]
    ]
], {
    nodeNum: BigNumber;
    parentNodeHash: string;
    nodeHash: string;
    executionHash: string;
    inboxMaxCount: BigNumber;
    afterInboxBatchEndCount: BigNumber;
    afterInboxBatchAcc: string;
    assertionBytes32Fields: [
        [
            string,
            string,
            string
        ],
        [
            string,
            string,
            string
        ]
    ];
    assertionIntFields: [
        [
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ],
        [
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ]
    ];
}>;
export declare type NodeCreatedEventFilter = TypedEventFilter<NodeCreatedEvent>;
export declare type NodeRejectedEvent = TypedEvent<[BigNumber], {
    nodeNum: BigNumber;
}>;
export declare type NodeRejectedEventFilter = TypedEventFilter<NodeRejectedEvent>;
export declare type RollupChallengeStartedEvent = TypedEvent<[
    string,
    string,
    string,
    BigNumber
], {
    challengeContract: string;
    asserter: string;
    challenger: string;
    challengedNode: BigNumber;
}>;
export declare type RollupChallengeStartedEventFilter = TypedEventFilter<RollupChallengeStartedEvent>;
export declare type RollupCreatedEvent = TypedEvent<[string], {
    machineHash: string;
}>;
export declare type RollupCreatedEventFilter = TypedEventFilter<RollupCreatedEvent>;
export declare type UserStakeUpdatedEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber
], {
    user: string;
    initialBalance: BigNumber;
    finalBalance: BigNumber;
}>;
export declare type UserStakeUpdatedEventFilter = TypedEventFilter<UserStakeUpdatedEvent>;
export declare type UserWithdrawableFundsUpdatedEvent = TypedEvent<[
    string,
    BigNumber,
    BigNumber
], {
    user: string;
    initialBalance: BigNumber;
    finalBalance: BigNumber;
}>;
export declare type UserWithdrawableFundsUpdatedEventFilter = TypedEventFilter<UserWithdrawableFundsUpdatedEvent>;
export interface RollupCore extends BaseContract {
    contractName: "RollupCore";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: RollupCoreInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        _stakerMap(arg0: string, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            string,
            boolean
        ] & {
            index: BigNumber;
            latestStakedNode: BigNumber;
            amountStaked: BigNumber;
            currentChallenge: string;
            isStaked: boolean;
        }>;
        amountStaked(staker: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<[string]>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<[BigNumber]>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<[boolean]>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<[boolean]>;
        lastStakeBlock(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestConfirmed(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestNodeCreated(overrides?: CallOverrides): Promise<[BigNumber]>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        stakerCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<[BigNumber]>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        zombieCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber]>;
    };
    _stakerMap(arg0: string, overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber,
        string,
        boolean
    ] & {
        index: BigNumber;
        latestStakedNode: BigNumber;
        amountStaked: BigNumber;
        currentChallenge: string;
        isStaked: boolean;
    }>;
    amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
    currentChallenge(staker: string, overrides?: CallOverrides): Promise<string>;
    firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
    getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<string>;
    getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
    isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>;
    isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>;
    lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
    latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
    latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
    latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
    stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
    withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
    zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
    zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
    zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    callStatic: {
        _stakerMap(arg0: string, overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            string,
            boolean
        ] & {
            index: BigNumber;
            latestStakedNode: BigNumber;
            amountStaked: BigNumber;
            currentChallenge: string;
            isStaked: boolean;
        }>;
        amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<string>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<string>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<boolean>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<boolean>;
        lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
        latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
        latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<string>;
        zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "NodeConfirmed(uint256,bytes32,uint256,bytes32,uint256)"(nodeNum?: BigNumberish | null, afterSendAcc?: null, afterSendCount?: null, afterLogAcc?: null, afterLogCount?: null): NodeConfirmedEventFilter;
        NodeConfirmed(nodeNum?: BigNumberish | null, afterSendAcc?: null, afterSendCount?: null, afterLogAcc?: null, afterLogCount?: null): NodeConfirmedEventFilter;
        "NodeCreated(uint256,bytes32,bytes32,bytes32,uint256,uint256,bytes32,bytes32[3][2],uint256[4][2])"(nodeNum?: BigNumberish | null, parentNodeHash?: BytesLike | null, nodeHash?: null, executionHash?: null, inboxMaxCount?: null, afterInboxBatchEndCount?: null, afterInboxBatchAcc?: null, assertionBytes32Fields?: null, assertionIntFields?: null): NodeCreatedEventFilter;
        NodeCreated(nodeNum?: BigNumberish | null, parentNodeHash?: BytesLike | null, nodeHash?: null, executionHash?: null, inboxMaxCount?: null, afterInboxBatchEndCount?: null, afterInboxBatchAcc?: null, assertionBytes32Fields?: null, assertionIntFields?: null): NodeCreatedEventFilter;
        "NodeRejected(uint256)"(nodeNum?: BigNumberish | null): NodeRejectedEventFilter;
        NodeRejected(nodeNum?: BigNumberish | null): NodeRejectedEventFilter;
        "RollupChallengeStarted(address,address,address,uint256)"(challengeContract?: string | null, asserter?: null, challenger?: null, challengedNode?: null): RollupChallengeStartedEventFilter;
        RollupChallengeStarted(challengeContract?: string | null, asserter?: null, challenger?: null, challengedNode?: null): RollupChallengeStartedEventFilter;
        "RollupCreated(bytes32)"(machineHash?: null): RollupCreatedEventFilter;
        RollupCreated(machineHash?: null): RollupCreatedEventFilter;
        "UserStakeUpdated(address,uint256,uint256)"(user?: string | null, initialBalance?: null, finalBalance?: null): UserStakeUpdatedEventFilter;
        UserStakeUpdated(user?: string | null, initialBalance?: null, finalBalance?: null): UserStakeUpdatedEventFilter;
        "UserWithdrawableFundsUpdated(address,uint256,uint256)"(user?: string | null, initialBalance?: null, finalBalance?: null): UserWithdrawableFundsUpdatedEventFilter;
        UserWithdrawableFundsUpdated(user?: string | null, initialBalance?: null, finalBalance?: null): UserWithdrawableFundsUpdatedEventFilter;
    };
    estimateGas: {
        _stakerMap(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        amountStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<BigNumber>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        lastStakeBlock(overrides?: CallOverrides): Promise<BigNumber>;
        latestConfirmed(overrides?: CallOverrides): Promise<BigNumber>;
        latestNodeCreated(overrides?: CallOverrides): Promise<BigNumber>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<BigNumber>;
        stakerCount(overrides?: CallOverrides): Promise<BigNumber>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<BigNumber>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        zombieCount(overrides?: CallOverrides): Promise<BigNumber>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        _stakerMap(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        amountStaked(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        currentChallenge(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        firstUnresolvedNode(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNode(nodeNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getNodeHash(index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        getStakerAddress(stakerNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isStaked(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isZombie(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        lastStakeBlock(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestConfirmed(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestNodeCreated(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        latestStakedNode(staker: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        stakerCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        withdrawableFunds(owner: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieAddress(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        zombieLatestStakedNode(zombieNum: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
