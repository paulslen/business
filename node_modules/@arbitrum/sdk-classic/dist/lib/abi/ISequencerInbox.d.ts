import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface ISequencerInboxInterface extends utils.Interface {
    contractName: "ISequencerInbox";
    functions: {
        "getInboxAccsLength()": FunctionFragment;
        "inboxAccs(uint256)": FunctionFragment;
        "isSequencer(address)": FunctionFragment;
        "maxDelayBlocks()": FunctionFragment;
        "maxDelaySeconds()": FunctionFragment;
        "messageCount()": FunctionFragment;
        "proveInboxContainsMessage(bytes,uint256)": FunctionFragment;
        "sequencer()": FunctionFragment;
        "setIsSequencer(address,bool)": FunctionFragment;
        "setMaxDelay(uint256,uint256)": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "getInboxAccsLength", values?: undefined): string;
    encodeFunctionData(functionFragment: "inboxAccs", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "isSequencer", values: [string]): string;
    encodeFunctionData(functionFragment: "maxDelayBlocks", values?: undefined): string;
    encodeFunctionData(functionFragment: "maxDelaySeconds", values?: undefined): string;
    encodeFunctionData(functionFragment: "messageCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "proveInboxContainsMessage", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "sequencer", values?: undefined): string;
    encodeFunctionData(functionFragment: "setIsSequencer", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "setMaxDelay", values: [BigNumberish, BigNumberish]): string;
    decodeFunctionResult(functionFragment: "getInboxAccsLength", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inboxAccs", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isSequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxDelayBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxDelaySeconds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "messageCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveInboxContainsMessage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "sequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setIsSequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMaxDelay", data: BytesLike): Result;
    events: {
        "DelayedInboxForced(uint256,bytes32,uint256,uint256,bytes32[2],uint256)": EventFragment;
        "IsSequencerUpdated(address,bool)": EventFragment;
        "MaxDelayUpdated(uint256,uint256)": EventFragment;
        "SequencerBatchDelivered(uint256,bytes32,uint256,bytes32,bytes,uint256[],uint256[],uint256,address)": EventFragment;
        "SequencerBatchDeliveredFromOrigin(uint256,bytes32,uint256,bytes32,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "DelayedInboxForced"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IsSequencerUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "MaxDelayUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SequencerBatchDelivered"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SequencerBatchDeliveredFromOrigin"): EventFragment;
}
export declare type DelayedInboxForcedEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    [string, string],
    BigNumber
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    totalDelayedMessagesRead: BigNumber;
    afterAccAndDelayed: [string, string];
    seqBatchIndex: BigNumber;
}>;
export declare type DelayedInboxForcedEventFilter = TypedEventFilter<DelayedInboxForcedEvent>;
export declare type IsSequencerUpdatedEvent = TypedEvent<[
    string,
    boolean
], {
    addr: string;
    isSequencer: boolean;
}>;
export declare type IsSequencerUpdatedEventFilter = TypedEventFilter<IsSequencerUpdatedEvent>;
export declare type MaxDelayUpdatedEvent = TypedEvent<[
    BigNumber,
    BigNumber
], {
    newMaxDelayBlocks: BigNumber;
    newMaxDelaySeconds: BigNumber;
}>;
export declare type MaxDelayUpdatedEventFilter = TypedEventFilter<MaxDelayUpdatedEvent>;
export declare type SequencerBatchDeliveredEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    string,
    string,
    BigNumber[],
    BigNumber[],
    BigNumber,
    string
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    afterAcc: string;
    transactions: string;
    lengths: BigNumber[];
    sectionsMetadata: BigNumber[];
    seqBatchIndex: BigNumber;
    sequencer: string;
}>;
export declare type SequencerBatchDeliveredEventFilter = TypedEventFilter<SequencerBatchDeliveredEvent>;
export declare type SequencerBatchDeliveredFromOriginEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    string,
    BigNumber
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    afterAcc: string;
    seqBatchIndex: BigNumber;
}>;
export declare type SequencerBatchDeliveredFromOriginEventFilter = TypedEventFilter<SequencerBatchDeliveredFromOriginEvent>;
export interface ISequencerInbox extends BaseContract {
    contractName: "ISequencerInbox";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: ISequencerInboxInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        getInboxAccsLength(overrides?: CallOverrides): Promise<[BigNumber]>;
        inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        isSequencer(seq: string, overrides?: CallOverrides): Promise<[boolean]>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<[BigNumber]>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<[BigNumber]>;
        messageCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        proveInboxContainsMessage(proof: BytesLike, inboxCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        sequencer(overrides?: CallOverrides): Promise<[string]>;
        setIsSequencer(addr: string, isSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
    };
    getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
    inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<string>;
    isSequencer(seq: string, overrides?: CallOverrides): Promise<boolean>;
    maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
    maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
    messageCount(overrides?: CallOverrides): Promise<BigNumber>;
    proveInboxContainsMessage(proof: BytesLike, inboxCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
    sequencer(overrides?: CallOverrides): Promise<string>;
    setIsSequencer(addr: string, isSequencer: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    callStatic: {
        getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
        inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<string>;
        isSequencer(seq: string, overrides?: CallOverrides): Promise<boolean>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
        messageCount(overrides?: CallOverrides): Promise<BigNumber>;
        proveInboxContainsMessage(proof: BytesLike, inboxCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        sequencer(overrides?: CallOverrides): Promise<string>;
        setIsSequencer(addr: string, isSequencer: boolean, overrides?: CallOverrides): Promise<void>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: CallOverrides): Promise<void>;
    };
    filters: {
        "DelayedInboxForced(uint256,bytes32,uint256,uint256,bytes32[2],uint256)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, totalDelayedMessagesRead?: null, afterAccAndDelayed?: null, seqBatchIndex?: null): DelayedInboxForcedEventFilter;
        DelayedInboxForced(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, totalDelayedMessagesRead?: null, afterAccAndDelayed?: null, seqBatchIndex?: null): DelayedInboxForcedEventFilter;
        "IsSequencerUpdated(address,bool)"(addr?: null, isSequencer?: null): IsSequencerUpdatedEventFilter;
        IsSequencerUpdated(addr?: null, isSequencer?: null): IsSequencerUpdatedEventFilter;
        "MaxDelayUpdated(uint256,uint256)"(newMaxDelayBlocks?: null, newMaxDelaySeconds?: null): MaxDelayUpdatedEventFilter;
        MaxDelayUpdated(newMaxDelayBlocks?: null, newMaxDelaySeconds?: null): MaxDelayUpdatedEventFilter;
        "SequencerBatchDelivered(uint256,bytes32,uint256,bytes32,bytes,uint256[],uint256[],uint256,address)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, transactions?: null, lengths?: null, sectionsMetadata?: null, seqBatchIndex?: null, sequencer?: null): SequencerBatchDeliveredEventFilter;
        SequencerBatchDelivered(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, transactions?: null, lengths?: null, sectionsMetadata?: null, seqBatchIndex?: null, sequencer?: null): SequencerBatchDeliveredEventFilter;
        "SequencerBatchDeliveredFromOrigin(uint256,bytes32,uint256,bytes32,uint256)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, seqBatchIndex?: null): SequencerBatchDeliveredFromOriginEventFilter;
        SequencerBatchDeliveredFromOrigin(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, seqBatchIndex?: null): SequencerBatchDeliveredFromOriginEventFilter;
    };
    estimateGas: {
        getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
        inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        isSequencer(seq: string, overrides?: CallOverrides): Promise<BigNumber>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
        messageCount(overrides?: CallOverrides): Promise<BigNumber>;
        proveInboxContainsMessage(proof: BytesLike, inboxCount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        sequencer(overrides?: CallOverrides): Promise<BigNumber>;
        setIsSequencer(addr: string, isSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
    };
    populateTransaction: {
        getInboxAccsLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inboxAccs(index: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isSequencer(seq: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        messageCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveInboxContainsMessage(proof: BytesLike, inboxCount: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        sequencer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setIsSequencer(addr: string, isSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
    };
}
