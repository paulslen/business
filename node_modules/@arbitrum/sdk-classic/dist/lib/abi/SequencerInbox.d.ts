import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export interface SequencerInboxInterface extends utils.Interface {
    contractName: "SequencerInbox";
    functions: {
        "addSequencerL2Batch(bytes,uint256[],uint256[],bytes32)": FunctionFragment;
        "addSequencerL2BatchFromOrigin(bytes,uint256[],uint256[],bytes32)": FunctionFragment;
        "addSequencerL2BatchFromOriginWithGasRefunder(bytes,uint256[],uint256[],bytes32,address)": FunctionFragment;
        "delayedInbox()": FunctionFragment;
        "forceInclusion(uint256,uint8,uint256[2],uint256,uint256,address,bytes32,bytes32)": FunctionFragment;
        "getInboxAccsLength()": FunctionFragment;
        "inboxAccs(uint256)": FunctionFragment;
        "initialize(address,address,address)": FunctionFragment;
        "isMaster()": FunctionFragment;
        "isSequencer(address)": FunctionFragment;
        "maxDelayBlocks()": FunctionFragment;
        "maxDelaySeconds()": FunctionFragment;
        "messageCount()": FunctionFragment;
        "postUpgradeInit()": FunctionFragment;
        "proveBatchContainsSequenceNumber(bytes,uint256)": FunctionFragment;
        "proveInboxContainsMessage(bytes,uint256)": FunctionFragment;
        "rollup()": FunctionFragment;
        "sequencer()": FunctionFragment;
        "setIsSequencer(address,bool)": FunctionFragment;
        "setMaxDelay(uint256,uint256)": FunctionFragment;
        "totalDelayedMessagesRead()": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "addSequencerL2Batch", values: [BytesLike, BigNumberish[], BigNumberish[], BytesLike]): string;
    encodeFunctionData(functionFragment: "addSequencerL2BatchFromOrigin", values: [BytesLike, BigNumberish[], BigNumberish[], BytesLike]): string;
    encodeFunctionData(functionFragment: "addSequencerL2BatchFromOriginWithGasRefunder", values: [BytesLike, BigNumberish[], BigNumberish[], BytesLike, string]): string;
    encodeFunctionData(functionFragment: "delayedInbox", values?: undefined): string;
    encodeFunctionData(functionFragment: "forceInclusion", values: [
        BigNumberish,
        BigNumberish,
        [
            BigNumberish,
            BigNumberish
        ],
        BigNumberish,
        BigNumberish,
        string,
        BytesLike,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "getInboxAccsLength", values?: undefined): string;
    encodeFunctionData(functionFragment: "inboxAccs", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "initialize", values: [string, string, string]): string;
    encodeFunctionData(functionFragment: "isMaster", values?: undefined): string;
    encodeFunctionData(functionFragment: "isSequencer", values: [string]): string;
    encodeFunctionData(functionFragment: "maxDelayBlocks", values?: undefined): string;
    encodeFunctionData(functionFragment: "maxDelaySeconds", values?: undefined): string;
    encodeFunctionData(functionFragment: "messageCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "postUpgradeInit", values?: undefined): string;
    encodeFunctionData(functionFragment: "proveBatchContainsSequenceNumber", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "proveInboxContainsMessage", values: [BytesLike, BigNumberish]): string;
    encodeFunctionData(functionFragment: "rollup", values?: undefined): string;
    encodeFunctionData(functionFragment: "sequencer", values?: undefined): string;
    encodeFunctionData(functionFragment: "setIsSequencer", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "setMaxDelay", values: [BigNumberish, BigNumberish]): string;
    encodeFunctionData(functionFragment: "totalDelayedMessagesRead", values?: undefined): string;
    decodeFunctionResult(functionFragment: "addSequencerL2Batch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addSequencerL2BatchFromOrigin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addSequencerL2BatchFromOriginWithGasRefunder", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "delayedInbox", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "forceInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "getInboxAccsLength", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inboxAccs", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isMaster", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isSequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxDelayBlocks", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxDelaySeconds", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "messageCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "postUpgradeInit", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveBatchContainsSequenceNumber", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "proveInboxContainsMessage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rollup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "sequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setIsSequencer", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMaxDelay", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalDelayedMessagesRead", data: BytesLike): Result;
    events: {
        "DelayedInboxForced(uint256,bytes32,uint256,uint256,bytes32[2],uint256)": EventFragment;
        "IsSequencerUpdated(address,bool)": EventFragment;
        "MaxDelayUpdated(uint256,uint256)": EventFragment;
        "SequencerBatchDelivered(uint256,bytes32,uint256,bytes32,bytes,uint256[],uint256[],uint256,address)": EventFragment;
        "SequencerBatchDeliveredFromOrigin(uint256,bytes32,uint256,bytes32,uint256)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "DelayedInboxForced"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "IsSequencerUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "MaxDelayUpdated"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SequencerBatchDelivered"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SequencerBatchDeliveredFromOrigin"): EventFragment;
}
export declare type DelayedInboxForcedEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    BigNumber,
    [string, string],
    BigNumber
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    totalDelayedMessagesRead: BigNumber;
    afterAccAndDelayed: [string, string];
    seqBatchIndex: BigNumber;
}>;
export declare type DelayedInboxForcedEventFilter = TypedEventFilter<DelayedInboxForcedEvent>;
export declare type IsSequencerUpdatedEvent = TypedEvent<[
    string,
    boolean
], {
    addr: string;
    isSequencer: boolean;
}>;
export declare type IsSequencerUpdatedEventFilter = TypedEventFilter<IsSequencerUpdatedEvent>;
export declare type MaxDelayUpdatedEvent = TypedEvent<[
    BigNumber,
    BigNumber
], {
    newMaxDelayBlocks: BigNumber;
    newMaxDelaySeconds: BigNumber;
}>;
export declare type MaxDelayUpdatedEventFilter = TypedEventFilter<MaxDelayUpdatedEvent>;
export declare type SequencerBatchDeliveredEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    string,
    string,
    BigNumber[],
    BigNumber[],
    BigNumber,
    string
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    afterAcc: string;
    transactions: string;
    lengths: BigNumber[];
    sectionsMetadata: BigNumber[];
    seqBatchIndex: BigNumber;
    sequencer: string;
}>;
export declare type SequencerBatchDeliveredEventFilter = TypedEventFilter<SequencerBatchDeliveredEvent>;
export declare type SequencerBatchDeliveredFromOriginEvent = TypedEvent<[
    BigNumber,
    string,
    BigNumber,
    string,
    BigNumber
], {
    firstMessageNum: BigNumber;
    beforeAcc: string;
    newMessageCount: BigNumber;
    afterAcc: string;
    seqBatchIndex: BigNumber;
}>;
export declare type SequencerBatchDeliveredFromOriginEventFilter = TypedEventFilter<SequencerBatchDeliveredFromOriginEvent>;
export interface SequencerInbox extends BaseContract {
    contractName: "SequencerInbox";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: SequencerInboxInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        addSequencerL2Batch(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        addSequencerL2BatchFromOrigin(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        addSequencerL2BatchFromOriginWithGasRefunder(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        delayedInbox(overrides?: CallOverrides): Promise<[string]>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTimestamp: [BigNumberish, BigNumberish], inboxSeqNum: BigNumberish, gasPriceL1: BigNumberish, sender: string, messageDataHash: BytesLike, delayedAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        getInboxAccsLength(overrides?: CallOverrides): Promise<[BigNumber]>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        initialize(_delayedInbox: string, _sequencer: string, _rollup: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isMaster(overrides?: CallOverrides): Promise<[boolean]>;
        isSequencer(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<[BigNumber]>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<[BigNumber]>;
        messageCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        postUpgradeInit(overrides?: CallOverrides): Promise<[void]>;
        proveBatchContainsSequenceNumber(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        proveInboxContainsMessage(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        rollup(overrides?: CallOverrides): Promise<[string]>;
        sequencer(overrides?: CallOverrides): Promise<[string]>;
        setIsSequencer(addr: string, newIsSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<[BigNumber]>;
    };
    addSequencerL2Batch(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    addSequencerL2BatchFromOrigin(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    addSequencerL2BatchFromOriginWithGasRefunder(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, gasRefunder: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    delayedInbox(overrides?: CallOverrides): Promise<string>;
    forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTimestamp: [BigNumberish, BigNumberish], inboxSeqNum: BigNumberish, gasPriceL1: BigNumberish, sender: string, messageDataHash: BytesLike, delayedAcc: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
    inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
    initialize(_delayedInbox: string, _sequencer: string, _rollup: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isMaster(overrides?: CallOverrides): Promise<boolean>;
    isSequencer(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
    maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
    messageCount(overrides?: CallOverrides): Promise<BigNumber>;
    postUpgradeInit(overrides?: CallOverrides): Promise<void>;
    proveBatchContainsSequenceNumber(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
    proveInboxContainsMessage(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
    rollup(overrides?: CallOverrides): Promise<string>;
    sequencer(overrides?: CallOverrides): Promise<string>;
    setIsSequencer(addr: string, newIsSequencer: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    callStatic: {
        addSequencerL2Batch(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: CallOverrides): Promise<void>;
        addSequencerL2BatchFromOrigin(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: CallOverrides): Promise<void>;
        addSequencerL2BatchFromOriginWithGasRefunder(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, gasRefunder: string, overrides?: CallOverrides): Promise<void>;
        delayedInbox(overrides?: CallOverrides): Promise<string>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTimestamp: [BigNumberish, BigNumberish], inboxSeqNum: BigNumberish, gasPriceL1: BigNumberish, sender: string, messageDataHash: BytesLike, delayedAcc: BytesLike, overrides?: CallOverrides): Promise<void>;
        getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
        initialize(_delayedInbox: string, _sequencer: string, _rollup: string, overrides?: CallOverrides): Promise<void>;
        isMaster(overrides?: CallOverrides): Promise<boolean>;
        isSequencer(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
        messageCount(overrides?: CallOverrides): Promise<BigNumber>;
        postUpgradeInit(overrides?: CallOverrides): Promise<void>;
        proveBatchContainsSequenceNumber(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        proveInboxContainsMessage(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<[BigNumber, string]>;
        rollup(overrides?: CallOverrides): Promise<string>;
        sequencer(overrides?: CallOverrides): Promise<string>;
        setIsSequencer(addr: string, newIsSequencer: boolean, overrides?: CallOverrides): Promise<void>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: CallOverrides): Promise<void>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "DelayedInboxForced(uint256,bytes32,uint256,uint256,bytes32[2],uint256)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, totalDelayedMessagesRead?: null, afterAccAndDelayed?: null, seqBatchIndex?: null): DelayedInboxForcedEventFilter;
        DelayedInboxForced(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, totalDelayedMessagesRead?: null, afterAccAndDelayed?: null, seqBatchIndex?: null): DelayedInboxForcedEventFilter;
        "IsSequencerUpdated(address,bool)"(addr?: null, isSequencer?: null): IsSequencerUpdatedEventFilter;
        IsSequencerUpdated(addr?: null, isSequencer?: null): IsSequencerUpdatedEventFilter;
        "MaxDelayUpdated(uint256,uint256)"(newMaxDelayBlocks?: null, newMaxDelaySeconds?: null): MaxDelayUpdatedEventFilter;
        MaxDelayUpdated(newMaxDelayBlocks?: null, newMaxDelaySeconds?: null): MaxDelayUpdatedEventFilter;
        "SequencerBatchDelivered(uint256,bytes32,uint256,bytes32,bytes,uint256[],uint256[],uint256,address)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, transactions?: null, lengths?: null, sectionsMetadata?: null, seqBatchIndex?: null, sequencer?: null): SequencerBatchDeliveredEventFilter;
        SequencerBatchDelivered(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, transactions?: null, lengths?: null, sectionsMetadata?: null, seqBatchIndex?: null, sequencer?: null): SequencerBatchDeliveredEventFilter;
        "SequencerBatchDeliveredFromOrigin(uint256,bytes32,uint256,bytes32,uint256)"(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, seqBatchIndex?: null): SequencerBatchDeliveredFromOriginEventFilter;
        SequencerBatchDeliveredFromOrigin(firstMessageNum?: BigNumberish | null, beforeAcc?: BytesLike | null, newMessageCount?: null, afterAcc?: null, seqBatchIndex?: null): SequencerBatchDeliveredFromOriginEventFilter;
    };
    estimateGas: {
        addSequencerL2Batch(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        addSequencerL2BatchFromOrigin(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        addSequencerL2BatchFromOriginWithGasRefunder(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        delayedInbox(overrides?: CallOverrides): Promise<BigNumber>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTimestamp: [BigNumberish, BigNumberish], inboxSeqNum: BigNumberish, gasPriceL1: BigNumberish, sender: string, messageDataHash: BytesLike, delayedAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        getInboxAccsLength(overrides?: CallOverrides): Promise<BigNumber>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(_delayedInbox: string, _sequencer: string, _rollup: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isMaster(overrides?: CallOverrides): Promise<BigNumber>;
        isSequencer(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<BigNumber>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<BigNumber>;
        messageCount(overrides?: CallOverrides): Promise<BigNumber>;
        postUpgradeInit(overrides?: CallOverrides): Promise<BigNumber>;
        proveBatchContainsSequenceNumber(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        proveInboxContainsMessage(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        rollup(overrides?: CallOverrides): Promise<BigNumber>;
        sequencer(overrides?: CallOverrides): Promise<BigNumber>;
        setIsSequencer(addr: string, newIsSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        addSequencerL2Batch(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        addSequencerL2BatchFromOrigin(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        addSequencerL2BatchFromOriginWithGasRefunder(transactions: BytesLike, lengths: BigNumberish[], sectionsMetadata: BigNumberish[], afterAcc: BytesLike, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        delayedInbox(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTimestamp: [BigNumberish, BigNumberish], inboxSeqNum: BigNumberish, gasPriceL1: BigNumberish, sender: string, messageDataHash: BytesLike, delayedAcc: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        getInboxAccsLength(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(_delayedInbox: string, _sequencer: string, _rollup: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isMaster(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        isSequencer(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxDelayBlocks(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxDelaySeconds(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        messageCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        postUpgradeInit(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveBatchContainsSequenceNumber(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        proveInboxContainsMessage(proof: BytesLike, _messageCount: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rollup(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        sequencer(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setIsSequencer(addr: string, newIsSequencer: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMaxDelay(newMaxDelayBlocks: BigNumberish, newMaxDelaySeconds: BigNumberish, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
