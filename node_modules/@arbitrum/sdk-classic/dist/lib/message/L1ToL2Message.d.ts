import { TransactionReceipt } from '@ethersproject/providers';
import { Provider } from '@ethersproject/abstract-provider';
import { Signer } from '@ethersproject/abstract-signer';
import { ContractTransaction } from '@ethersproject/contracts';
import { BigNumber } from '@ethersproject/bignumber';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
export declare enum L2TxnType {
    L2_TX = 0,
    AUTO_REDEEM = 1
}
export declare enum L1ToL2MessageStatus {
    /**
     * The retryable ticket has yet to be created
     */
    NOT_YET_CREATED = 1,
    /**
     * An attempt was made to create the retryable ticket, but it failed.
     * This could be due to not enough submission cost being paid by the L1 transaction
     */
    CREATION_FAILED = 2,
    /**
     * The retryable ticket has been created but has not been redeemed. This could be due to the
     * auto redeem failing, or if the params (max l2 gas price) * (max l2 gas) = 0 then no auto
     * redeem tx is ever issued. An auto redeem is also never issued for ETH deposits.
     * A manual redeem is now required.
     */
    FUNDS_DEPOSITED_ON_L2 = 3,
    /**
     * The retryable ticket has been redeemed (either by auto, or manually) and the
     * l2 transaction has been executed
     */
    REDEEMED = 4,
    /**
     * The message has either expired or has been canceled. It can no longer be redeemed.
     */
    EXPIRED = 5
}
export interface L1toL2MessageInputs {
    /**
     * Destination address for L2 message
     */
    destinationAddress: string;
    /**
     * Call value in L2 message
     */
    l2CallValue: BigNumber;
    /**
     * Max gas deducted from L2 balance to cover base submission fee
     */
    maxSubmissionCost: BigNumber;
    /**
     * L2 address address to credit (maxgas x gasprice - execution cost)
     */
    excessFeeRefundAddress: string;
    /**
     *  Address to credit l2Callvalue on L2 if retryable txn times out or gets cancelled
     */
    callValueRefundAddress: string;
    /**
     * Max gas deducted from user's L2 balance to cover L2 execution
     */
    maxGas: BigNumber;
    /**
     * Gas price bid for L2 execution
     */
    gasPriceBid: BigNumber;
    /**
     * Length in bytes calldata of L2 message
     */
    callDataLength: BigNumber;
}
/**
 * Conditional type for Signer or Provider. If T is of type Provider
 * then L1ToL2MessageReaderOrWriter<T> will be of type L1ToL2MessageReader.
 * If T is of type Signer then L1ToL2MessageReaderOrWriter<T> will be of
 * type L1ToL2MessageWriter.
 */
export declare type L1ToL2MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? L1ToL2MessageReader : L1ToL2MessageWriter;
export declare class L1ToL2Message {
    readonly messageNumber: BigNumber;
    /**
     * When messages are sent from L1 to L2 a retryable ticket is created on L2.
     * The retryableCreationId can be used to retrieve information about the success or failure of the
     * creation of the retryable ticket.
     */
    readonly retryableCreationId: string;
    /**
     * When a retryable ticket is created a redeem of it will immediately be attempted.
     * The redemption may fail due to not enough gas, or the transaction may revert.
     * The result of this auto-redeem can be accessed by requesting the receipt associated
     * with this autoRedeemId.
     *
     * Note: If no call data is supplied to the retryable ticket an redemption will not be
     * attempted, and instead any value associated with the ticket will be sent directly to the
     * destination. In this case no receipt will be available for the autoRedeemId
     */
    readonly autoRedeemId: string;
    /**
     * If a retryable ticket is successfully redeemed (either via auto-redeem or manually)
     * and l2 transaction will be executed for the payload specified in the retryable ticket.
     * This is the hash of that transaction, and as such no receipt will exist for this hash
     * until the ticket has been successfully redeemed.
     */
    readonly l2TxHash: string;
    private static bitFlip;
    private static calculateL2DerivedHash;
    static calculateRetryableCreationId(l2ChainId: BigNumber, messageNumber: BigNumber): string;
    static calculateAutoRedeemId(retryableCreationId: string): string;
    static calculateL2TxHash(retryableCreationId: string): string;
    static fromRetryableCreationId<T extends SignerOrProvider>(l2SignerOrProvider: T, retryableCreationId: string, messageNumber: BigNumber): L1ToL2MessageReaderOrWriter<T>;
    constructor(retryableCreationId: string, messageNumber: BigNumber);
}
/**
 * If the status is redeemed an l2TxReceipt is populated.
 * For all other statuses l2TxReceipt is not populated
 */
export declare type L1ToL2MessageWaitResult = {
    status: L1ToL2MessageStatus.REDEEMED;
    l2TxReceipt: TransactionReceipt;
} | {
    status: Exclude<L1ToL2MessageStatus, L1ToL2MessageStatus.REDEEMED>;
};
export declare class L1ToL2MessageReader extends L1ToL2Message {
    readonly l2Provider: Provider;
    constructor(l2Provider: Provider, retryableCreationId: string, messageNumber: BigNumber);
    /**
     * Try to get the receipt for the retryable ticket. See L1ToL2Message.retryableCreationId
     * May throw an error if retryable ticket has yet to be created
     * @returns
     */
    getRetryableCreationReceipt(): Promise<TransactionReceipt>;
    /**
     * Receipt for the auto redeem attempt. See L1ToL2Message.autoRedeemId.
     * May throw an error if no auto-redeem attempt was made. This is the case for
     * transactions with no call data
     * @returns
     */
    getAutoRedeemReceipt(): Promise<TransactionReceipt>;
    /**
     * Receipt for the l2 transaction created by this message. See L1ToL2Message.l2TxHash
     * May throw an error if the l2 transaction has yet to be executed, which is the case if
     * the retryable ticket has not been created and redeemed.
     * @returns
     */
    getL2TxReceipt(): Promise<TransactionReceipt>;
    /**
     * Has this message expired. Once expired the retryable ticket can no longer be redeemed.
     * @returns
     */
    isExpired(): Promise<boolean>;
    /**
     * Get and format inputs provided in calldata for retryable messsage (message type 9)
     */
    getInputs(): Promise<L1toL2MessageInputs>;
    protected receiptsToStatus(retryableCreationReceipt: TransactionReceipt | null | undefined, l2TxReceipt: TransactionReceipt | null | undefined): Promise<L1ToL2MessageStatus>;
    status(): Promise<L1ToL2MessageStatus>;
    /**
     * Wait for the retryable ticket to be created, for it to be redeemed, and for the l2Tx to be executed.
     * Note: The terminal status of a transaction that only does an eth deposit is FUNDS_DEPOSITED_ON_L2 as
     * no L2 transaction needs to be executed, however the terminal state of any other transaction is REDEEMED
     * which represents that the retryable ticket has been redeemed and the L2 tx has been executed.
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains a status, and optionally the l2TxReceipt.
     * If the status is "REDEEMED" then a l2TxReceipt is also available on the result.
     * If the status has any other value then l2TxReceipt is not populated.
     */
    waitForStatus(confirmations?: number, timeout?: number): Promise<L1ToL2MessageWaitResult>;
    /**
     * How long until this message expires
     * @returns
     */
    getTimeout(): Promise<BigNumber>;
    /**
     * Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled.
     * The Beneficiary is also the address with the right to cancel a Retryable Ticket (if the ticket hasnâ€™t been redeemed yet).
     * @returns
     */
    getBeneficiary(): Promise<string>;
}
export declare class L1ToL2MessageWriter extends L1ToL2MessageReader {
    readonly l2Signer: Signer;
    constructor(l2Signer: Signer, retryableCreationId: string, messageNumber: BigNumber);
    /**
     * Manually redeem the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    redeem(): Promise<ContractTransaction>;
    /**
     * Cancel the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    cancel(): Promise<ContractTransaction>;
}
