import { Provider } from '@ethersproject/abstract-provider';
import { Signer } from '@ethersproject/abstract-signer';
import { BigNumber } from '@ethersproject/bignumber';
import { BlockTag } from '@ethersproject/abstract-provider';
import { L2ToL1TransactionEvent } from '../abi/ArbSys';
import { ContractTransaction } from 'ethers';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
export interface MessageBatchProofInfo {
    /**
     * Merkle proof of message inclusion in outbox entry
     */
    proof: string[];
    /**
     * Merkle path to message
     */
    path: BigNumber;
    /**
     * Sender of original message (i.e., caller of ArbSys.sendTxToL1)
     */
    l2Sender: string;
    /**
     * Destination address for L1 contract call
     */
    l1Dest: string;
    /**
     * L2 block number at which sendTxToL1 call was made
     */
    l2Block: BigNumber;
    /**
     * L1 block number at which sendTxToL1 call was made
     */
    l1Block: BigNumber;
    /**
     * L2 Timestamp at which sendTxToL1 call was made
     */
    timestamp: BigNumber;
    /**
     * Value in L1 message in wei
     */
    amount: BigNumber;
    /**
     * ABI-encoded L1 message data
     */
    calldataForL1: string;
}
export declare enum L2ToL1MessageStatus {
    /**
     * No corresponding L2ToL1Event emitted
     */
    NOT_FOUND = 0,
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    UNCONFIRMED = 1,
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    CONFIRMED = 2,
    /**
     * Outgoing message executed (terminal state)
     */
    EXECUTED = 3
}
/**
 * Conditional type for Signer or Provider. If T is of type Provider
 * then L2ToL1MessageReaderOrWriter<T> will be of type L2ToL1MessageReader.
 * If T is of type Signer then L2ToL1MessageReaderOrWriter<T> will be of
 * type L2ToL1MessageWriter.
 */
export declare type L2ToL1MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? L2ToL1MessageReader : L2ToL1MessageWriter;
export declare class L2ToL1Message {
    /**
     * The number of the batch this message is part of
     */
    readonly batchNumber: BigNumber;
    /**
     * The index of this message in the batch
     */
    readonly indexInBatch: BigNumber;
    protected constructor(batchNumber: BigNumber, indexInBatch: BigNumber);
    static fromBatchNumber<T extends SignerOrProvider>(l1SignerOrProvider: T, outboxAddress: string, batchNumber: BigNumber, indexInBatch: BigNumber): L2ToL1MessageReaderOrWriter<T>;
    static getL2ToL1MessageLogs(l2Provider: Provider, filter: {
        fromBlock: BlockTag;
        toBlock: BlockTag;
    }, batchNumber?: BigNumber, destination?: string, uniqueId?: BigNumber, indexInBatch?: BigNumber): Promise<L2ToL1TransactionEvent['args'][]>;
}
/**
 * Provides read-only access for l2-to-l1-messages
 */
export declare class L2ToL1MessageReader extends L2ToL1Message {
    protected readonly l1Provider: Provider;
    protected readonly outboxAddress: string;
    constructor(l1Provider: Provider, outboxAddress: string, batchNumber: BigNumber, indexInBatch: BigNumber);
    private outboxEntryExists;
    static tryGetProof(l2Provider: Provider, batchNumber: BigNumber, indexInBatch: BigNumber): Promise<MessageBatchProofInfo | null>;
    /**
     * Get the execution proof for this message. Returns null if the batch does not exist yet.
     * @param l2Provider
     * @returns
     */
    tryGetProof(l2Provider: Provider): Promise<MessageBatchProofInfo | null>;
    /**
     * Check if given outbox message has already been executed
     */
    hasExecuted(proofInfo: MessageBatchProofInfo): Promise<boolean>;
    /**
     * Get the status of this message
     * In order to check if the message has been executed proof info must be provided.
     * @param proofInfo
     * @returns
     */
    status(proofInfo: MessageBatchProofInfo | null): Promise<L2ToL1MessageStatus>;
    /**
     * Waits until the outbox entry has been created, and will not return until it has been.
     * WARNING: Outbox entries are only created when the corresponding node is confirmed. Which
     * can take 1 week+, so waiting here could be a very long operation.
     * @param retryDelay
     * @returns
     */
    waitUntilOutboxEntryCreated(retryDelay?: number): Promise<void>;
    /**
     * Estimates the L1 block number in which this L2 to L1 tx will be available for execution
     * @param l2Provider
     * @returns expected L1 block number where the L2 to L1 message will be executable
     */
    getFirstExecutableBlock(l2Provider: Provider): Promise<BigNumber>;
}
/**
 * Provides read and write access for l2-to-l1-messages
 */
export declare class L2ToL1MessageWriter extends L2ToL1MessageReader {
    private readonly l1Signer;
    constructor(l1Signer: Signer, outboxAddress: string, batchNumber: BigNumber, indexInBatch: BigNumber);
    /**
     * Executes the L2ToL1Message on L1.
     * Will throw an error if the outbox entry has not been created, which happens when the
     * corresponding assertion is confirmed.
     * @returns
     */
    execute(proofInfo: MessageBatchProofInfo): Promise<ContractTransaction>;
}
