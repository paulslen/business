/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ToL2MessageWriter = exports.L1ToL2MessageReader = exports.L1ToL2Message = exports.L1ToL2MessageStatus = exports.L2TxnType = void 0;
const bignumber_1 = require("@ethersproject/bignumber");
const keccak256_1 = require("@ethersproject/keccak256");
const bytes_1 = require("@ethersproject/bytes");
const ArbRetryableTx__factory_1 = require("../abi/factories/ArbRetryableTx__factory");
const constants_1 = require("../dataEntities/constants");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const errors_1 = require("../dataEntities/errors");
const utils_1 = require("ethers/lib/utils");
var L2TxnType;
(function (L2TxnType) {
    L2TxnType[L2TxnType["L2_TX"] = 0] = "L2_TX";
    L2TxnType[L2TxnType["AUTO_REDEEM"] = 1] = "AUTO_REDEEM";
})(L2TxnType = exports.L2TxnType || (exports.L2TxnType = {}));
var L1ToL2MessageStatus;
(function (L1ToL2MessageStatus) {
    /**
     * The retryable ticket has yet to be created
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["NOT_YET_CREATED"] = 1] = "NOT_YET_CREATED";
    /**
     * An attempt was made to create the retryable ticket, but it failed.
     * This could be due to not enough submission cost being paid by the L1 transaction
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["CREATION_FAILED"] = 2] = "CREATION_FAILED";
    /**
     * The retryable ticket has been created but has not been redeemed. This could be due to the
     * auto redeem failing, or if the params (max l2 gas price) * (max l2 gas) = 0 then no auto
     * redeem tx is ever issued. An auto redeem is also never issued for ETH deposits.
     * A manual redeem is now required.
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["FUNDS_DEPOSITED_ON_L2"] = 3] = "FUNDS_DEPOSITED_ON_L2";
    /**
     * The retryable ticket has been redeemed (either by auto, or manually) and the
     * l2 transaction has been executed
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["REDEEMED"] = 4] = "REDEEMED";
    /**
     * The message has either expired or has been canceled. It can no longer be redeemed.
     */
    L1ToL2MessageStatus[L1ToL2MessageStatus["EXPIRED"] = 5] = "EXPIRED";
})(L1ToL2MessageStatus = exports.L1ToL2MessageStatus || (exports.L1ToL2MessageStatus = {}));
class L1ToL2Message {
    constructor(retryableCreationId, messageNumber) {
        this.messageNumber = messageNumber;
        this.retryableCreationId = retryableCreationId;
        this.autoRedeemId = L1ToL2Message.calculateAutoRedeemId(this.retryableCreationId);
        this.l2TxHash = L1ToL2Message.calculateL2TxHash(this.retryableCreationId);
    }
    static bitFlip(num) {
        return num.or(bignumber_1.BigNumber.from(1).shl(255));
    }
    static calculateL2DerivedHash(retryableCreationId, l2TxnType) {
        return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
            (0, bytes_1.zeroPad)(retryableCreationId, 32),
            (0, bytes_1.zeroPad)(bignumber_1.BigNumber.from(l2TxnType).toHexString(), 32),
        ]));
    }
    static calculateRetryableCreationId(l2ChainId, messageNumber) {
        return (0, keccak256_1.keccak256)((0, bytes_1.concat)([
            (0, bytes_1.zeroPad)(l2ChainId.toHexString(), 32),
            (0, bytes_1.zeroPad)(L1ToL2Message.bitFlip(messageNumber).toHexString(), 32),
        ]));
    }
    static calculateAutoRedeemId(retryableCreationId) {
        return this.calculateL2DerivedHash(retryableCreationId, L2TxnType.AUTO_REDEEM);
    }
    static calculateL2TxHash(retryableCreationId) {
        return this.calculateL2DerivedHash(retryableCreationId, L2TxnType.L2_TX);
    }
    static fromRetryableCreationId(l2SignerOrProvider, retryableCreationId, messageNumber) {
        return signerOrProvider_1.SignerProviderUtils.isSigner(l2SignerOrProvider)
            ? new L1ToL2MessageWriter(l2SignerOrProvider, retryableCreationId, messageNumber)
            : new L1ToL2MessageReader(l2SignerOrProvider, retryableCreationId, messageNumber);
    }
}
exports.L1ToL2Message = L1ToL2Message;
class L1ToL2MessageReader extends L1ToL2Message {
    constructor(l2Provider, retryableCreationId, messageNumber) {
        super(retryableCreationId, messageNumber);
        this.l2Provider = l2Provider;
    }
    /**
     * Try to get the receipt for the retryable ticket. See L1ToL2Message.retryableCreationId
     * May throw an error if retryable ticket has yet to be created
     * @returns
     */
    getRetryableCreationReceipt() {
        return this.l2Provider.getTransactionReceipt(this.retryableCreationId);
    }
    /**
     * Receipt for the auto redeem attempt. See L1ToL2Message.autoRedeemId.
     * May throw an error if no auto-redeem attempt was made. This is the case for
     * transactions with no call data
     * @returns
     */
    getAutoRedeemReceipt() {
        return this.l2Provider.getTransactionReceipt(this.autoRedeemId);
    }
    /**
     * Receipt for the l2 transaction created by this message. See L1ToL2Message.l2TxHash
     * May throw an error if the l2 transaction has yet to be executed, which is the case if
     * the retryable ticket has not been created and redeemed.
     * @returns
     */
    getL2TxReceipt() {
        return this.l2Provider.getTransactionReceipt(this.l2TxHash);
    }
    /**
     * Has this message expired. Once expired the retryable ticket can no longer be redeemed.
     * @returns
     */
    async isExpired() {
        const currentTimestamp = bignumber_1.BigNumber.from((await this.l2Provider.getBlock('latest')).timestamp);
        const timeoutTimestamp = await this.getTimeout();
        // timeoutTimestamp returns the timestamp at which the retryable ticket expires
        // it can also return 0 if the ticket l2Tx does not exist
        return currentTimestamp.gte(timeoutTimestamp);
    }
    /**
     * Get and format inputs provided in calldata for retryable messsage (message type 9)
     */
    async getInputs() {
        const txData = (await this.l2Provider.getTransaction(this.retryableCreationId)).data;
        // Ignore first 4 bytes: message ID
        const inputsData = (0, utils_1.hexDataSlice)(txData, 4);
        const [destinationAddress, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, maxGas, gasPriceBid, _sizeOfCallDataLength, //** Specifies encoding for dynamic length arrays */
        callDataLength,] = utils_1.defaultAbiCoder.decode([
            'address',
            'uint256',
            'uint256',
            'address',
            'address',
            'uint256',
            'uint256',
            'uint256',
            'uint256',
        ], inputsData);
        // sanity check
        if (_sizeOfCallDataLength.toNumber() !== 256)
            throw new errors_1.ArbTsError(`Error getting Msg inputs data; unrecognized encoding. Execpeted ${_sizeOfCallDataLength.toNumber()} to be 256 `);
        return {
            destinationAddress,
            l2CallValue,
            maxSubmissionCost,
            excessFeeRefundAddress,
            callValueRefundAddress,
            maxGas,
            gasPriceBid,
            callDataLength,
        };
    }
    async receiptsToStatus(retryableCreationReceipt, l2TxReceipt) {
        // happy path for non auto redeemable messages
        // NOT_YET_CREATED -> FUNDS_DEPOSITED
        // these will later either transition to EXPIRED after the timeout
        // (this is what happens to eth deposits since they don't need to be
        // redeemed) or to REDEEMED if the retryable is manually redeemed
        // happy path for auto redeemable messages
        // NOT_YET_CREATED -> FUNDS_DEPOSITED -> REDEEMED
        // an attempt to auto redeem executable messages is made immediately
        // after the retryable is created - which if successful will transition
        // the status to REDEEMED. If the auto redeem fails then the ticket
        // will transition to REDEEMED if manually redeemed, or EXPIRE
        // after the timeout is reached and the ticket is not redeemed
        // we test the retryable receipt first as if this doesnt exist there's
        // no point looking to see if expired
        if (!retryableCreationReceipt) {
            return L1ToL2MessageStatus.NOT_YET_CREATED;
        }
        if (retryableCreationReceipt.status === 0) {
            return L1ToL2MessageStatus.CREATION_FAILED;
        }
        // ticket created, has it been redeemed?
        if (l2TxReceipt && l2TxReceipt.status === 1) {
            return L1ToL2MessageStatus.REDEEMED;
        }
        // not redeemed, has it now expired
        if (await this.isExpired()) {
            return L1ToL2MessageStatus.EXPIRED;
        }
        // ticket was created but not redeemed
        // this could be because
        // a) the ticket is non auto redeemable (l2GasPrice == 0 || l2GasLimit == 0) -
        //    this is usually an eth deposit. But in some rare case the
        //    user may still want to manually redeem it
        // b) the ticket is auto redeemable, but the auto redeem failed
        // the fact that the auto redeem failed isn't usually useful to the user
        // if they're doing an eth deposit they don't care about redemption
        // and if they do want execution to occur they will know that they're
        // here because the auto redeem failed. If they really want to check
        // they can fetch the auto redeem receipt and check the status on it
        return L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2;
    }
    async status() {
        return this.receiptsToStatus(await this.getRetryableCreationReceipt(), await this.getL2TxReceipt());
    }
    /**
     * Wait for the retryable ticket to be created, for it to be redeemed, and for the l2Tx to be executed.
     * Note: The terminal status of a transaction that only does an eth deposit is FUNDS_DEPOSITED_ON_L2 as
     * no L2 transaction needs to be executed, however the terminal state of any other transaction is REDEEMED
     * which represents that the retryable ticket has been redeemed and the L2 tx has been executed.
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains a status, and optionally the l2TxReceipt.
     * If the status is "REDEEMED" then a l2TxReceipt is also available on the result.
     * If the status has any other value then l2TxReceipt is not populated.
     */
    async waitForStatus(confirmations, timeout = 900000) {
        // try to wait for the retryable ticket to be created
        let retryableCreationReceipt;
        try {
            retryableCreationReceipt = await this.l2Provider.waitForTransaction(this.retryableCreationId, confirmations, timeout);
        }
        catch (err) {
            if (err.message.includes('timeout exceeded')) {
                // do nothing - this is dependent on the timeout passed in
            }
            else
                throw err;
        }
        // get the l2TxReceipt, don't bother trying if we couldn't get the retryableCreationReceipt
        const l2TxReceipt = retryableCreationReceipt
            ? await this.getL2TxReceipt()
            : undefined;
        const status = await this.receiptsToStatus(retryableCreationReceipt, l2TxReceipt);
        if (status === L1ToL2MessageStatus.REDEEMED) {
            return {
                // if the status is redeemed we know the l2TxReceipt must exist
                l2TxReceipt: l2TxReceipt,
                status,
            };
        }
        else {
            return {
                status,
            };
        }
    }
    /**
     * How long until this message expires
     * @returns
     */
    getTimeout() {
        const arbRetryableTx = ArbRetryableTx__factory_1.ArbRetryableTx__factory.connect(constants_1.ARB_RETRYABLE_TX_ADDRESS, this.l2Provider);
        return arbRetryableTx.getTimeout(this.l2TxHash);
    }
    /**
     * Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled.
     * The Beneficiary is also the address with the right to cancel a Retryable Ticket (if the ticket hasn’t been redeemed yet).
     * @returns
     */
    getBeneficiary() {
        const arbRetryableTx = ArbRetryableTx__factory_1.ArbRetryableTx__factory.connect(constants_1.ARB_RETRYABLE_TX_ADDRESS, this.l2Provider);
        return arbRetryableTx.getBeneficiary(this.l2TxHash);
    }
}
exports.L1ToL2MessageReader = L1ToL2MessageReader;
class L1ToL2MessageWriter extends L1ToL2MessageReader {
    constructor(l2Signer, retryableCreationId, messageNumber) {
        super(l2Signer.provider, retryableCreationId, messageNumber);
        this.l2Signer = l2Signer;
        if (!l2Signer.provider)
            throw new Error('Signer not connected to provider.');
    }
    /**
     * Manually redeem the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    async redeem() {
        const status = await this.status();
        if (status === L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2) {
            const arbRetryableTx = ArbRetryableTx__factory_1.ArbRetryableTx__factory.connect(constants_1.ARB_RETRYABLE_TX_ADDRESS, this.l2Signer);
            return await arbRetryableTx.redeem(this.l2TxHash);
        }
        else {
            throw new errors_1.ArbTsError(`Cannot redeem. Message status: ${status} must be: ${L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2}.`);
        }
    }
    /**
     * Cancel the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    async cancel() {
        const status = await this.status();
        if (status === L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2) {
            const arbRetryableTx = ArbRetryableTx__factory_1.ArbRetryableTx__factory.connect(constants_1.ARB_RETRYABLE_TX_ADDRESS, this.l2Signer);
            return await arbRetryableTx.cancel(this.l2TxHash);
        }
        else {
            throw new errors_1.ArbTsError(`Cannot cancel. Message status: ${status} must be: ${L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2}.`);
        }
    }
}
exports.L1ToL2MessageWriter = L1ToL2MessageWriter;
