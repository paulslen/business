/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var _a;
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2TransactionReceipt = void 0;
const ArbSys__factory_1 = require("../abi/factories/ArbSys__factory");
const networks_1 = require("../dataEntities/networks");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const L2ToL1Message_1 = require("./L2ToL1Message");
const __1 = require("../..");
const lib_1 = require("../utils/lib");
class L2TransactionReceipt {
    constructor(tx) {
        this.to = tx.to;
        this.from = tx.from;
        this.contractAddress = tx.contractAddress;
        this.transactionIndex = tx.transactionIndex;
        this.root = tx.root;
        this.gasUsed = tx.gasUsed;
        this.logsBloom = tx.logsBloom;
        this.blockHash = tx.blockHash;
        this.transactionHash = tx.transactionHash;
        this.logs = tx.logs;
        this.blockNumber = tx.blockNumber;
        this.confirmations = tx.confirmations;
        this.cumulativeGasUsed = tx.cumulativeGasUsed;
        this.effectiveGasPrice = tx.effectiveGasPrice;
        this.byzantium = tx.byzantium;
        this.type = tx.type;
        this.status = tx.status;
    }
    /**
     * Get an L2ToL1Transaction events created by this transaction
     * @returns
     */
    getL2ToL1Events() {
        const iface = ArbSys__factory_1.ArbSys__factory.createInterface();
        const l2ToL1Event = iface.getEvent('L2ToL1Transaction');
        const eventTopic = iface.getEventTopic(l2ToL1Event);
        const logs = this.logs.filter(log => log.topics[0] === eventTopic);
        return logs.map(log => iface.parseLog(log).args);
    }
    async getL2ToL1Messages(l1SignerOrProvider, l2Network) {
        const provider = signerOrProvider_1.SignerProviderUtils.getProvider(l1SignerOrProvider);
        if (!provider)
            throw new Error('Signer not connected to provider.');
        return this.getL2ToL1Events().map(log => {
            const outboxAddr = (0, networks_1.getOutboxAddr)(l2Network, log.batchNumber);
            return L2ToL1Message_1.L2ToL1Message.fromBatchNumber(l1SignerOrProvider, outboxAddr, log.batchNumber, log.indexInBatch);
        });
    }
    /**
     * Whether the data associated with this transaction has been
     * made available on L1
     */
    async isDataAvailable(l2Provider, l1Provider) {
        const arbReceipt = await (0, __1.getRawArbTransactionReceipt)(l2Provider, this.transactionHash, l1Provider);
        // Data is made available in batches, if the batch info is
        // available then so is the tx data
        return (0, lib_1.isDefined)(arbReceipt === null || arbReceipt === void 0 ? void 0 : arbReceipt.l1InboxBatchInfo);
    }
}
exports.L2TransactionReceipt = L2TransactionReceipt;
_a = L2TransactionReceipt;
/**
 * Replaces the wait function with one that returns an L2TransactionReceipt
 * @param contractTransaction
 * @returns
 */
L2TransactionReceipt.monkeyPatchWait = (contractTransaction) => {
    const wait = contractTransaction.wait;
    contractTransaction.wait = async (_confirmations) => {
        // we ignore the confirmations for now since L2 transactions shouldn't re-org
        // in future we should give users a more fine grained way to check the finality of
        // an l2 transaction - check if a batch is on L1, if an assertion has been made, and if
        // it has been confirmed.
        const result = await wait();
        return new L2TransactionReceipt(result);
    };
    return contractTransaction;
};
