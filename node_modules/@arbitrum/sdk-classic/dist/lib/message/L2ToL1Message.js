/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2ToL1MessageWriter = exports.L2ToL1MessageReader = exports.L2ToL1Message = exports.L2ToL1MessageStatus = void 0;
const constants_1 = require("../dataEntities/constants");
const bignumber_1 = require("@ethersproject/bignumber");
const ArbSys__factory_1 = require("../abi/factories/ArbSys__factory");
const IOutbox__factory_1 = require("../abi/factories/IOutbox__factory");
const Outbox__factory_1 = require("../abi/factories/Outbox__factory");
const RollupUserFacet__factory_1 = require("../abi/factories/RollupUserFacet__factory");
const Node__factory_1 = require("../abi/factories/Node__factory");
const NodeInterface__factory_1 = require("../abi/factories/NodeInterface__factory");
const eventFetcher_1 = require("../utils/eventFetcher");
const errors_1 = require("../dataEntities/errors");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const networks_1 = require("../dataEntities/networks");
const lib_1 = require("../utils/lib");
var L2ToL1MessageStatus;
(function (L2ToL1MessageStatus) {
    /**
     * No corresponding L2ToL1Event emitted
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["NOT_FOUND"] = 0] = "NOT_FOUND";
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["UNCONFIRMED"] = 1] = "UNCONFIRMED";
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["CONFIRMED"] = 2] = "CONFIRMED";
    /**
     * Outgoing message executed (terminal state)
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["EXECUTED"] = 3] = "EXECUTED";
})(L2ToL1MessageStatus = exports.L2ToL1MessageStatus || (exports.L2ToL1MessageStatus = {}));
class L2ToL1Message {
    constructor(batchNumber, indexInBatch) {
        this.batchNumber = batchNumber;
        this.indexInBatch = indexInBatch;
    }
    static fromBatchNumber(l1SignerOrProvider, outboxAddress, batchNumber, indexInBatch) {
        return signerOrProvider_1.SignerProviderUtils.isSigner(l1SignerOrProvider)
            ? new L2ToL1MessageWriter(l1SignerOrProvider, outboxAddress, batchNumber, indexInBatch)
            : new L2ToL1MessageReader(l1SignerOrProvider, outboxAddress, batchNumber, indexInBatch);
    }
    static async getL2ToL1MessageLogs(l2Provider, filter, batchNumber, destination, uniqueId, indexInBatch) {
        const eventFetcher = new eventFetcher_1.EventFetcher(l2Provider);
        const events = (await eventFetcher.getEvents(constants_1.ARB_SYS_ADDRESS, ArbSys__factory_1.ArbSys__factory, t => t.filters.L2ToL1Transaction(null, destination, uniqueId, batchNumber), filter)).map(l => l.event);
        if (indexInBatch) {
            const indexItems = events.filter(b => b.indexInBatch.eq(indexInBatch));
            if (indexItems.length === 1) {
                return indexItems;
            }
            else if (indexItems.length > 1) {
                throw new errors_1.ArbTsError('More than one indexed item found in batch.');
            }
            else
                return [];
        }
        else
            return events;
    }
}
exports.L2ToL1Message = L2ToL1Message;
/**
 * Provides read-only access for l2-to-l1-messages
 */
class L2ToL1MessageReader extends L2ToL1Message {
    constructor(l1Provider, outboxAddress, batchNumber, indexInBatch) {
        super(batchNumber, indexInBatch);
        this.l1Provider = l1Provider;
        this.outboxAddress = outboxAddress;
    }
    async outboxEntryExists() {
        const outbox = IOutbox__factory_1.IOutbox__factory.connect(this.outboxAddress, this.l1Provider);
        return await outbox.outboxEntryExists(this.batchNumber);
    }
    static async tryGetProof(l2Provider, batchNumber, indexInBatch) {
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, l2Provider);
        try {
            return nodeInterface.lookupMessageBatchProof(batchNumber, indexInBatch);
        }
        catch (e) {
            const expectedError = "batch doesn't exist";
            const err = e;
            const actualError = err && (err.message || (err.error && err.error.message));
            if (actualError.includes(expectedError))
                return null;
            else
                throw e;
        }
    }
    /**
     * Get the execution proof for this message. Returns null if the batch does not exist yet.
     * @param l2Provider
     * @returns
     */
    async tryGetProof(l2Provider) {
        return await L2ToL1MessageReader.tryGetProof(l2Provider, this.batchNumber, this.indexInBatch);
    }
    /**
     * Check if given outbox message has already been executed
     */
    async hasExecuted(proofInfo) {
        var _a, _b;
        const outbox = Outbox__factory_1.Outbox__factory.connect(this.outboxAddress, this.l1Provider);
        try {
            await outbox.callStatic.executeTransaction(this.batchNumber, proofInfo.proof, proofInfo.path, proofInfo.l2Sender, proofInfo.l1Dest, proofInfo.l2Block, proofInfo.l1Block, proofInfo.timestamp, proofInfo.amount, proofInfo.calldataForL1);
            return false;
        }
        catch (err) {
            const e = err;
            if ((_a = e === null || e === void 0 ? void 0 : e.message) === null || _a === void 0 ? void 0 : _a.toString().includes('ALREADY_SPENT'))
                return true;
            if ((_b = e === null || e === void 0 ? void 0 : e.message) === null || _b === void 0 ? void 0 : _b.toString().includes('NO_OUTBOX_ENTRY'))
                return false;
            throw e;
        }
    }
    /**
     * Get the status of this message
     * In order to check if the message has been executed proof info must be provided.
     * @param proofInfo
     * @returns
     */
    async status(proofInfo) {
        try {
            if (proofInfo) {
                const messageExecuted = await this.hasExecuted(proofInfo);
                if (messageExecuted) {
                    return L2ToL1MessageStatus.EXECUTED;
                }
            }
            const outboxEntryExists = await this.outboxEntryExists();
            return outboxEntryExists
                ? L2ToL1MessageStatus.CONFIRMED
                : L2ToL1MessageStatus.UNCONFIRMED;
        }
        catch (e) {
            console.warn('666: error in fetching status:', e);
            return L2ToL1MessageStatus.NOT_FOUND;
        }
    }
    /**
     * Waits until the outbox entry has been created, and will not return until it has been.
     * WARNING: Outbox entries are only created when the corresponding node is confirmed. Which
     * can take 1 week+, so waiting here could be a very long operation.
     * @param retryDelay
     * @returns
     */
    async waitUntilOutboxEntryCreated(retryDelay = 500) {
        const exists = await this.outboxEntryExists();
        if (exists) {
            return;
        }
        else {
            await (0, lib_1.wait)(retryDelay);
            await this.waitUntilOutboxEntryCreated(retryDelay);
        }
    }
    /**
     * Estimates the L1 block number in which this L2 to L1 tx will be available for execution
     * @param l2Provider
     * @returns expected L1 block number where the L2 to L1 message will be executable
     */
    async getFirstExecutableBlock(l2Provider) {
        // expected number of L1 blocks that it takes for an L2 tx to be included in a L1 assertion
        const ASSERTION_CREATED_PADDING = 50;
        // expected number of L1 blocks that it takes for a validator to confirm an L1 block after the node deadline is passed
        const ASSERTION_CONFIRMED_PADDING = 20;
        // TODO: create version that queries multiple L2 to L1 txs, so a single multicall can make all requests
        // we assume the L2 to L1 tx is valid, but we could check that on the constructor that the L2 to L1 msg is valid
        const network = await (0, networks_1.getL2Network)(l2Provider);
        // TODO: use IRollupUser interface instead
        const rollup = RollupUserFacet__factory_1.RollupUserFacet__factory.connect(network.ethBridge.rollup, this.l1Provider);
        const proof = await this.tryGetProof(l2Provider);
        // here we assume the L2 to L1 tx is actually valid, so the user needs to wait the max time.
        if (proof === null)
            return bignumber_1.BigNumber.from(network.confirmPeriodBlocks)
                .add(ASSERTION_CREATED_PADDING)
                .add(ASSERTION_CONFIRMED_PADDING);
        // we can't check if the L2 to L1 tx isSpent on the outbox, so we instead try executing it
        if (await this.hasExecuted(proof))
            return bignumber_1.BigNumber.from(0);
        const latestBlock = await this.l1Provider.getBlockNumber();
        const eventFetcher = new eventFetcher_1.EventFetcher(this.l1Provider);
        const events = (await eventFetcher.getEvents(network.ethBridge.rollup, RollupUserFacet__factory_1.RollupUserFacet__factory, t => t.filters.NodeCreated(), {
            // ~40k blocks with a 15sec blocktime and 8days confirmPeriodBlocks
            fromBlock: latestBlock -
                bignumber_1.BigNumber.from(network.confirmPeriodBlocks)
                    .add(ASSERTION_CONFIRMED_PADDING)
                    .toNumber(),
            toBlock: latestBlock,
        }))
            .map(e => e.event)
            .filter(e => {
            const afterSendCount = e.assertionIntFields[1][2];
            return bignumber_1.BigNumber.from(afterSendCount).gte(this.batchNumber);
        })
            .sort((a, b) => {
            return (bignumber_1.BigNumber.from(a.assertionIntFields[1][2]).toNumber() -
                bignumber_1.BigNumber.from(b.assertionIntFields[1][2]).toNumber());
        });
        // a node that covers this tx still has not been created
        if (events.length === 0)
            return bignumber_1.BigNumber.from(network.confirmPeriodBlocks)
                .add(ASSERTION_CREATED_PADDING)
                .add(ASSERTION_CONFIRMED_PADDING);
        const rollupNode = await rollup.callStatic.getNode(events[0].nodeNum);
        const node = Node__factory_1.Node__factory.connect(rollupNode, this.l1Provider);
        return node
            .deadlineBlock()
            .then(blockNum => blockNum.add(ASSERTION_CONFIRMED_PADDING));
    }
}
exports.L2ToL1MessageReader = L2ToL1MessageReader;
/**
 * Provides read and write access for l2-to-l1-messages
 */
class L2ToL1MessageWriter extends L2ToL1MessageReader {
    constructor(l1Signer, outboxAddress, batchNumber, indexInBatch) {
        super(l1Signer.provider, outboxAddress, batchNumber, indexInBatch);
        this.l1Signer = l1Signer;
    }
    /**
     * Executes the L2ToL1Message on L1.
     * Will throw an error if the outbox entry has not been created, which happens when the
     * corresponding assertion is confirmed.
     * @returns
     */
    async execute(proofInfo) {
        const status = await this.status(proofInfo);
        if (status !== L2ToL1MessageStatus.CONFIRMED) {
            throw new errors_1.ArbTsError(`Cannot execute message. Status is: ${status} but must be ${L2ToL1MessageStatus.CONFIRMED}.`);
        }
        const outbox = Outbox__factory_1.Outbox__factory.connect(this.outboxAddress, this.l1Signer);
        // We can predict and print number of missing blocks
        // if not challenged
        return await outbox.functions.executeTransaction(this.batchNumber, proofInfo.proof, proofInfo.path, proofInfo.l2Sender, proofInfo.l1Dest, proofInfo.l2Block, proofInfo.l1Block, proofInfo.timestamp, proofInfo.amount, proofInfo.calldataForL1);
    }
}
exports.L2ToL1MessageWriter = L2ToL1MessageWriter;
