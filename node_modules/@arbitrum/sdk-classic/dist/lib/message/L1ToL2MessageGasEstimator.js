"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ToL2MessageGasEstimator = void 0;
const NodeInterface__factory_1 = require("../abi/factories/NodeInterface__factory");
const ArbRetryableTx__factory_1 = require("../abi/factories/ArbRetryableTx__factory");
const constants_1 = require("../dataEntities/constants");
const bignumber_1 = require("@ethersproject/bignumber");
const ethers_1 = require("ethers");
const ethers_2 = require("ethers");
const DEFAULT_SUBMISSION_PRICE_PERCENT_INCREASE = bignumber_1.BigNumber.from(340);
// Temporary workaround for incorrect gas estimation from NodeInterface when there is gas refund
const DEFAULT_MAX_GAS_PERCENT_INCREASE = bignumber_1.BigNumber.from(50);
const defaultL1ToL2MessageEstimateOptions = {
    maxSubmissionFeePercentIncrease: DEFAULT_SUBMISSION_PRICE_PERCENT_INCREASE,
    maxGasPercentIncrease: DEFAULT_MAX_GAS_PERCENT_INCREASE,
    maxGasPricePercentIncrease: ethers_1.constants.Zero,
    sendL2CallValueFromL1: true,
};
class L1ToL2MessageGasEstimator {
    constructor(l2Provider) {
        this.l2Provider = l2Provider;
    }
    percentIncrease(num, increase) {
        return num.add(num.mul(increase).div(100));
    }
    applySubmissionPriceDefaults(maxSubmissionPrice) {
        return {
            base: maxSubmissionPrice === null || maxSubmissionPrice === void 0 ? void 0 : maxSubmissionPrice.base,
            percentIncrease: (maxSubmissionPrice === null || maxSubmissionPrice === void 0 ? void 0 : maxSubmissionPrice.percentIncrease) ||
                defaultL1ToL2MessageEstimateOptions.maxSubmissionFeePercentIncrease,
        };
    }
    /**
     * Return the price, in wei, of submitting a new retryable tx with a given calldata size.
     * @param callDataSize
     * @param options
     * @returns
     */
    async estimateSubmissionPrice(callDataSize, options) {
        const defaultedOptions = this.applySubmissionPriceDefaults(options);
        const arbRetryableTx = ArbRetryableTx__factory_1.ArbRetryableTx__factory.connect(constants_1.ARB_RETRYABLE_TX_ADDRESS, this.l2Provider);
        const [currentSubmissionPrice, nextUpdateTimestamp] = await arbRetryableTx.getSubmissionPrice(callDataSize);
        // Apply percent increase
        const submissionPrice = this.percentIncrease(defaultedOptions.base || currentSubmissionPrice, defaultedOptions.percentIncrease);
        return {
            submissionPrice,
            nextUpdateTimestamp,
        };
    }
    /**
     * Estimate the amount of L2 gas required for putting the transaction in the L2 inbox, and executing it.
     * @param sender
     * @param senderDeposit
     * @param destAddr
     * @param l2CallValue
     * @param maxSubmissionCost
     * @param excessFeeRefundAddress
     * @param callValueRefundAddress
     * @param maxGas
     * @param gasPriceBid
     * @param calldata
     * @returns
     */
    async estimateRetryableTicketMaxGas(sender, senderDeposit, destAddr, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, maxGas, gasPriceBid, calldata) {
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, this.l2Provider);
        return (await nodeInterface.estimateRetryableTicket(sender, senderDeposit, destAddr, l2CallValue, maxSubmissionCost, excessFeeRefundAddress, callValueRefundAddress, maxGas, gasPriceBid, calldata))[0];
    }
    applyDefaults(options) {
        var _a, _b, _c, _d, _e;
        return {
            maxGas: {
                base: (_a = options === null || options === void 0 ? void 0 : options.maxGas) === null || _a === void 0 ? void 0 : _a.base,
                percentIncrease: ((_b = options === null || options === void 0 ? void 0 : options.maxGas) === null || _b === void 0 ? void 0 : _b.percentIncrease) ||
                    defaultL1ToL2MessageEstimateOptions.maxGasPercentIncrease,
                min: ((_c = options === null || options === void 0 ? void 0 : options.maxGas) === null || _c === void 0 ? void 0 : _c.min) || ethers_1.constants.Zero,
            },
            maxGasPrice: {
                base: (_d = options === null || options === void 0 ? void 0 : options.maxGasPrice) === null || _d === void 0 ? void 0 : _d.base,
                percentIncrease: ((_e = options === null || options === void 0 ? void 0 : options.maxGasPrice) === null || _e === void 0 ? void 0 : _e.percentIncrease) ||
                    defaultL1ToL2MessageEstimateOptions.maxGasPricePercentIncrease,
            },
            sendL2CallValueFromL1: typeof (options === null || options === void 0 ? void 0 : options.sendL2CallValueFromL1) === 'boolean'
                ? options === null || options === void 0 ? void 0 : options.sendL2CallValueFromL1
                : defaultL1ToL2MessageEstimateOptions.sendL2CallValueFromL1,
        };
    }
    /**
     * Get gas limit, gas price and submission price estimates for sending an L2 message
     * @param sender Sender of the L1 to L2 transaction
     * @param destAddr Destination L2 contract address
     * @param l2CallDataHex The call data to be sent in the request
     * @param l2CallValue The value to be sent on L2 as part of the L2 transaction
     * @param options
     * @returns
     */
    async estimateMessage(sender, destAddr, l2CallDataHex, l2CallValue, options) {
        const defaultedOptions = this.applyDefaults(options);
        const maxGasPriceBid = this.percentIncrease(defaultedOptions.maxGasPrice.base ||
            (await this.l2Provider.getGasPrice()), defaultedOptions.maxGasPrice.percentIncrease);
        const maxSubmissionPriceBid = (await this.estimateSubmissionPrice(ethers_2.utils.hexDataLength(l2CallDataHex), options === null || options === void 0 ? void 0 : options.maxSubmissionPrice)).submissionPrice;
        const calculatedMaxGas = this.percentIncrease(defaultedOptions.maxGas.base ||
            (await this.estimateRetryableTicketMaxGas(sender, ethers_2.utils
                .parseEther('1')
                .add(l2CallValue) /** we add a 1 ether "deposit" buffer to pay for execution in the gas estimation  */, destAddr, l2CallValue, maxSubmissionPriceBid, sender, sender, ethers_1.constants.Zero, maxGasPriceBid, l2CallDataHex)), defaultedOptions.maxGas.percentIncrease);
        // always ensure the max gas is greater than the min
        const maxGas = calculatedMaxGas.gt(defaultedOptions.maxGas.min)
            ? calculatedMaxGas
            : defaultedOptions.maxGas.min;
        let totalDepositValue = maxSubmissionPriceBid.add(maxGasPriceBid.mul(maxGas));
        if (defaultedOptions.sendL2CallValueFromL1) {
            totalDepositValue = totalDepositValue.add(l2CallValue);
        }
        return {
            maxGasBid: maxGas,
            maxSubmissionPriceBid,
            maxGasPriceBid,
            totalDepositValue,
        };
    }
}
exports.L1ToL2MessageGasEstimator = L1ToL2MessageGasEstimator;
