import { Provider } from '@ethersproject/abstract-provider';
import { BigNumber } from '@ethersproject/bignumber';
/**
 * An optional big number percentage increase
 */
export declare type PercentIncrease = {
    /**
     * If provided, will override the estimated base
     */
    base?: BigNumber;
    /**
     * How much to increase the base by. If not provided system defaults may be used.
     */
    percentIncrease?: BigNumber;
};
export interface GasOverrides {
    gasLimit?: PercentIncrease & {
        /**
         * Set a minimum max gas
         */
        min?: BigNumber;
    };
    maxSubmissionFee?: PercentIncrease;
    maxFeePerGas?: PercentIncrease;
}
export declare class L1ToL2MessageGasEstimator {
    readonly l2Provider: Provider;
    constructor(l2Provider: Provider);
    private percentIncrease;
    private applySubmissionPriceDefaults;
    private applyMaxFeePerGasDefaults;
    private applyGasLimitDefaults;
    /**
     * Return the fee, in wei, of submitting a new retryable tx with a given calldata size.
     * @param l1BaseFee
     * @param callDataSize
     * @param options
     * @returns
     */
    estimateSubmissionFee(l1Provider: Provider, l1BaseFee: BigNumber, callDataSize: BigNumber | number, options?: PercentIncrease): Promise<BigNumber>;
    /**
     * Estimate the amount of L2 gas required for putting the transaction in the L2 inbox, and executing it.
     * @param sender
     * @param destAddr
     * @param l2CallValue
     * @param excessFeeRefundAddress
     * @param callValueRefundAddress
     * @param calldata
     * @param senderDeposit we dont know how much gas the transaction will use when executing
     * so by default we supply a dummy amount of call value that will definately be more than we need
     * @returns
     */
    estimateRetryableTicketGasLimit(sender: string, destAddr: string, l2CallValue: BigNumber, excessFeeRefundAddress: string, callValueRefundAddress: string, calldata: string, senderDeposit?: BigNumber): Promise<BigNumber>;
    /**
     * Get gas limit, gas price and submission price estimates for sending an L1->L2 message
     * @param sender Sender of the L1 to L2 transaction
     * @param l2CallTo Destination L2 contract address
     * @param l2CallData The hex call data to be sent in the request
     * @param l2CallValue The value to be sent on L2 as part of the L2 transaction
     * @param l1BaseFee Current l1 base fee
     * @param excessFeeRefundAddress The address to send excess fee refunds too
     * @param callValueRefundAddress The address to send the call value
     * @param options
     * @returns
     */
    estimateAll(sender: string, l2CallTo: string, l2CallData: string, l2CallValue: BigNumber, l1BaseFee: BigNumber, excessFeeRefundAddress: string, callValueRefundAddress: string, l1Provider: Provider, options?: GasOverrides): Promise<{
        gasLimit: BigNumber;
        maxSubmissionFee: BigNumber;
        maxFeePerGas: BigNumber;
        totalL2GasCosts: BigNumber;
    }>;
}
