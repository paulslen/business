/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2ToL1MessageWriter = exports.L2ToL1MessageReader = exports.L2ToL1Message = exports.L2ToL1MessageStatus = void 0;
const constants_1 = require("../dataEntities/constants");
const bignumber_1 = require("@ethersproject/bignumber");
const ArbSys__factory_1 = require("../abi/factories/ArbSys__factory");
const RollupUserLogic__factory_1 = require("../abi/factories/RollupUserLogic__factory");
const Outbox__factory_1 = require("../abi/factories/Outbox__factory");
const NodeInterface__factory_1 = require("../abi/factories/NodeInterface__factory");
const eventFetcher_1 = require("../utils/eventFetcher");
const errors_1 = require("../dataEntities/errors");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const lib_1 = require("../utils/lib");
const networks_1 = require("../dataEntities/networks");
const arbProvider_1 = require("../utils/arbProvider");
var L2ToL1MessageStatus;
(function (L2ToL1MessageStatus) {
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["UNCONFIRMED"] = 1] = "UNCONFIRMED";
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["CONFIRMED"] = 2] = "CONFIRMED";
    /**
     * Outgoing message executed (terminal state)
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["EXECUTED"] = 3] = "EXECUTED";
})(L2ToL1MessageStatus = exports.L2ToL1MessageStatus || (exports.L2ToL1MessageStatus = {}));
// expected number of L1 blocks that it takes for an L2 tx to be included in a L1 assertion
const ASSERTION_CREATED_PADDING = 50;
// expected number of L1 blocks that it takes for a validator to confirm an L1 block after the node deadline is passed
const ASSERTION_CONFIRMED_PADDING = 20;
/**
 * Base functionality for L2->L1 messages
 */
class L2ToL1Message {
    constructor(event) {
        this.event = event;
    }
    static fromEvent(l1SignerOrProvider, event) {
        return signerOrProvider_1.SignerProviderUtils.isSigner(l1SignerOrProvider)
            ? new L2ToL1MessageWriter(l1SignerOrProvider, event)
            : new L2ToL1MessageReader(l1SignerOrProvider, event);
    }
    static async getL2ToL1Events(l2Provider, filter, position, destination, hash) {
        const eventFetcher = new eventFetcher_1.EventFetcher(l2Provider);
        return (await eventFetcher.getEvents(constants_1.ARB_SYS_ADDRESS, ArbSys__factory_1.ArbSys__factory, t => t.filters.L2ToL1Tx(null, destination, hash, position), filter)).map(l => l.event);
    }
}
exports.L2ToL1Message = L2ToL1Message;
/**
 * Provides read-only access for l2-to-l1-messages
 */
class L2ToL1MessageReader extends L2ToL1Message {
    constructor(l1Provider, event) {
        super(event);
        this.l1Provider = l1Provider;
    }
    async getOutboxProof(l2Provider) {
        const { sendRootSize } = await this.getSendProps(l2Provider);
        if (!sendRootSize)
            throw new errors_1.ArbSdkError('Node not yet confirmed, cannot get proof.');
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, l2Provider);
        const outboxProofParams = await nodeInterface.callStatic.constructOutboxProof(sendRootSize.toNumber(), this.event.position.toNumber());
        return outboxProofParams.proof;
    }
    /**
     * Check if this message has already been executed in the Outbox
     */
    async hasExecuted(l2Provider) {
        const l2Network = await (0, networks_1.getL2Network)(l2Provider);
        const outbox = Outbox__factory_1.Outbox__factory.connect(l2Network.ethBridge.outbox, this.l1Provider);
        return outbox.callStatic.spent(this.event.position);
    }
    /**
     * Get the status of this message
     * In order to check if the message has been executed proof info must be provided.
     * @returns
     */
    async status(l2Provider) {
        const { sendRootHash } = await this.getSendProps(l2Provider);
        if (!sendRootHash)
            return L2ToL1MessageStatus.UNCONFIRMED;
        return (await this.hasExecuted(l2Provider))
            ? L2ToL1MessageStatus.EXECUTED
            : L2ToL1MessageStatus.CONFIRMED;
    }
    parseNodeCreatedAssertion(event) {
        return {
            afterState: {
                blockHash: event.event.assertion.afterState.globalState.bytes32Vals[0],
                sendRoot: event.event.assertion.afterState.globalState.bytes32Vals[1],
            },
        };
    }
    async getBlockFromNodeLog(l2Provider, log) {
        const parsedLog = this.parseNodeCreatedAssertion(log);
        const arbitrumProvider = new arbProvider_1.ArbitrumProvider(l2Provider);
        const l2Block = await arbitrumProvider.getBlock(parsedLog.afterState.blockHash);
        if (!l2Block) {
            throw new errors_1.ArbSdkError(`Block not found. ${parsedLog.afterState.blockHash}`);
        }
        if (l2Block.sendRoot !== parsedLog.afterState.sendRoot) {
            throw new errors_1.ArbSdkError(`L2 block send root doesn't match parsed log. ${l2Block.sendRoot} ${parsedLog.afterState.sendRoot}`);
        }
        return l2Block;
    }
    async getBlockFromNodeNum(rollup, nodeNum, l2Provider) {
        const node = await rollup.getNode(nodeNum);
        // now get the block hash and sendroot for that node
        const eventFetcher = new eventFetcher_1.EventFetcher(rollup.provider);
        const logs = await eventFetcher.getEvents(rollup.address, RollupUserLogic__factory_1.RollupUserLogic__factory, t => t.filters.NodeCreated(nodeNum), {
            fromBlock: node.createdAtBlock.toNumber(),
            toBlock: node.createdAtBlock.toNumber(),
        });
        if (logs.length !== 1)
            throw new errors_1.ArbSdkError('No NodeConfirmed events found');
        return await this.getBlockFromNodeLog(l2Provider, logs[0]);
    }
    async getBatchNumber(l2Provider) {
        if (this.l1BatchNumber == undefined) {
            // findBatchContainingBlock errors if block number does not exist
            try {
                const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, l2Provider);
                const res = await nodeInterface.findBatchContainingBlock(this.event.arbBlockNum);
                this.l1BatchNumber = res.toNumber();
            }
            catch (err) {
                // do nothing - errors are expected here
            }
        }
        return this.l1BatchNumber;
    }
    async getSendProps(l2Provider) {
        if (!this.sendRootHash) {
            const l2Network = await (0, networks_1.getL2Network)(l2Provider);
            const rollup = RollupUserLogic__factory_1.RollupUserLogic__factory.connect(l2Network.ethBridge.rollup, this.l1Provider);
            const latestConfirmedNodeNum = await rollup.callStatic.latestConfirmed();
            const l2Block = await this.getBlockFromNodeNum(rollup, latestConfirmedNodeNum, l2Provider);
            const sendRootSize = bignumber_1.BigNumber.from(l2Block.sendCount);
            if (sendRootSize.gt(this.event.position)) {
                this.sendRootSize = sendRootSize;
                this.sendRootHash = l2Block.sendRoot;
            }
        }
        return {
            sendRootSize: this.sendRootSize,
            sendRootHash: this.sendRootHash,
        };
    }
    /**
     * Waits until the outbox entry has been created, and will not return until it has been.
     * WARNING: Outbox entries are only created when the corresponding node is confirmed. Which
     * can take 1 week+, so waiting here could be a very long operation.
     * @param retryDelay
     * @returns
     */
    async waitUntilReadyToExecute(l2Provider, retryDelay = 500) {
        const status = await this.status(l2Provider);
        if (status === L2ToL1MessageStatus.CONFIRMED ||
            status === L2ToL1MessageStatus.EXECUTED) {
            return;
        }
        else {
            await (0, lib_1.wait)(retryDelay);
            await this.waitUntilReadyToExecute(l2Provider, retryDelay);
        }
    }
    /**
     * Estimates the L1 block number in which this L2 to L1 tx will be available for execution.
     * If the message can or already has been executed, this returns null
     * @param l2Provider
     * @returns expected L1 block number where the L2 to L1 message will be executable. Returns null if the message can or already has been executed
     */
    async getFirstExecutableBlock(l2Provider) {
        const l2Network = await (0, networks_1.getL2Network)(l2Provider);
        const rollup = RollupUserLogic__factory_1.RollupUserLogic__factory.connect(l2Network.ethBridge.rollup, this.l1Provider);
        const status = await this.status(l2Provider);
        if (status === L2ToL1MessageStatus.EXECUTED)
            return null;
        if (status === L2ToL1MessageStatus.CONFIRMED)
            return null;
        // consistency check in case we change the enum in the future
        if (status !== L2ToL1MessageStatus.UNCONFIRMED)
            throw new errors_1.ArbSdkError('L2ToL1Msg expected to be unconfirmed');
        const latestBlock = await this.l1Provider.getBlockNumber();
        const eventFetcher = new eventFetcher_1.EventFetcher(this.l1Provider);
        const logs = (await eventFetcher.getEvents(rollup.address, RollupUserLogic__factory_1.RollupUserLogic__factory, t => t.filters.NodeCreated(), {
            fromBlock: Math.max(latestBlock -
                bignumber_1.BigNumber.from(l2Network.confirmPeriodBlocks)
                    .add(ASSERTION_CONFIRMED_PADDING)
                    .toNumber(), 0),
            toBlock: 'latest',
        })).sort((a, b) => a.event.nodeNum.toNumber() - b.event.nodeNum.toNumber());
        // here we assume the L2 to L1 tx is actually valid, so the user needs to wait the max time
        // since there isn't a pending node that includes this message yet
        if (logs.length === 0)
            return bignumber_1.BigNumber.from(l2Network.confirmPeriodBlocks)
                .add(ASSERTION_CREATED_PADDING)
                .add(ASSERTION_CONFIRMED_PADDING)
                .add(latestBlock);
        let foundLog = undefined;
        for (const log of logs) {
            const l2Block = await this.getBlockFromNodeLog(l2Provider, log);
            const sendCount = bignumber_1.BigNumber.from(l2Block.sendCount);
            if (sendCount.gte(this.event.position)) {
                foundLog = log;
                break;
            }
        }
        // here we assume the L2 to L1 tx is actually valid, so the user needs to wait the max time
        // since there isn't a pending node that includes this message yet
        if (!foundLog)
            return bignumber_1.BigNumber.from(l2Network.confirmPeriodBlocks)
                .add(ASSERTION_CREATED_PADDING)
                .add(ASSERTION_CONFIRMED_PADDING)
                .add(latestBlock);
        const earliestNodeWithExit = foundLog.event.nodeNum;
        const node = await rollup.getNode(earliestNodeWithExit);
        return node.deadlineBlock.add(ASSERTION_CONFIRMED_PADDING);
    }
}
exports.L2ToL1MessageReader = L2ToL1MessageReader;
/**
 * Provides read and write access for l2-to-l1-messages
 */
class L2ToL1MessageWriter extends L2ToL1MessageReader {
    constructor(l1Signer, event) {
        super(l1Signer.provider, event);
        this.l1Signer = l1Signer;
    }
    /**
     * Executes the L2ToL1Message on L1.
     * Will throw an error if the outbox entry has not been created, which happens when the
     * corresponding assertion is confirmed.
     * @returns
     */
    async execute(l2Provider, overrides) {
        const status = await this.status(l2Provider);
        if (status !== L2ToL1MessageStatus.CONFIRMED) {
            throw new errors_1.ArbSdkError(`Cannot execute message. Status is: ${status} but must be ${L2ToL1MessageStatus.CONFIRMED}.`);
        }
        const proof = await this.getOutboxProof(l2Provider);
        const l2Network = await (0, networks_1.getL2Network)(l2Provider);
        const outbox = Outbox__factory_1.Outbox__factory.connect(l2Network.ethBridge.outbox, this.l1Signer);
        return await outbox.executeTransaction(proof, this.event.position, this.event.caller, this.event.destination, this.event.arbBlockNum, this.event.ethBlockNum, this.event.timestamp, this.event.callvalue, this.event.data, overrides || {});
    }
}
exports.L2ToL1MessageWriter = L2ToL1MessageWriter;
