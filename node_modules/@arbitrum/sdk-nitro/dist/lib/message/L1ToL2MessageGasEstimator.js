"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.L1ToL2MessageGasEstimator = void 0;
const NodeInterface__factory_1 = require("../abi/factories/NodeInterface__factory");
const Inbox__factory_1 = require("../abi/factories/Inbox__factory");
const constants_1 = require("../dataEntities/constants");
const bignumber_1 = require("@ethersproject/bignumber");
const ethers_1 = require("ethers");
const ethers_2 = require("ethers");
const networks_1 = require("../dataEntities/networks");
/**
 * The default amount to increase the maximum submission cost. Submission cost is calculated
 * from (call data size * some const * l1 base fee). So we need to provide some leeway for
 * base fee increase. Since submission fee is a small amount it isn't too bas for UX to increase
 * it by a large amount, and provide better safety.
 */
const DEFAULT_SUBMISSION_FEE_PERCENT_INCREASE = bignumber_1.BigNumber.from(300);
/**
 * When submitting a retryable we need to estimate what the gas price for it will be when we actually come
 * to execute it. Since the l2 price can move due to congestion we should provide some padding here
 */
const DEFAULT_GAS_PRICE_PERCENT_INCREASE = bignumber_1.BigNumber.from(200);
const defaultL1ToL2MessageEstimateOptions = {
    maxSubmissionFeePercentIncrease: DEFAULT_SUBMISSION_FEE_PERCENT_INCREASE,
    // gas limit for l1->l2 messages should be predictable. If it isn't due to the nature
    // of the specific transaction, then the caller should provide a 'min' override
    gasLimitPercentIncrease: ethers_1.constants.Zero,
    maxFeePerGasPercentIncrease: DEFAULT_GAS_PRICE_PERCENT_INCREASE,
};
class L1ToL2MessageGasEstimator {
    constructor(l2Provider) {
        this.l2Provider = l2Provider;
    }
    percentIncrease(num, increase) {
        return num.add(num.mul(increase).div(100));
    }
    applySubmissionPriceDefaults(maxSubmissionFeeOptions) {
        return {
            base: maxSubmissionFeeOptions === null || maxSubmissionFeeOptions === void 0 ? void 0 : maxSubmissionFeeOptions.base,
            percentIncrease: (maxSubmissionFeeOptions === null || maxSubmissionFeeOptions === void 0 ? void 0 : maxSubmissionFeeOptions.percentIncrease) ||
                defaultL1ToL2MessageEstimateOptions.maxSubmissionFeePercentIncrease,
        };
    }
    applyMaxFeePerGasDefaults(maxFeePerGasOptions) {
        return {
            base: maxFeePerGasOptions === null || maxFeePerGasOptions === void 0 ? void 0 : maxFeePerGasOptions.base,
            percentIncrease: (maxFeePerGasOptions === null || maxFeePerGasOptions === void 0 ? void 0 : maxFeePerGasOptions.percentIncrease) ||
                defaultL1ToL2MessageEstimateOptions.maxFeePerGasPercentIncrease,
        };
    }
    applyGasLimitDefaults(gasLimitDefaults) {
        return {
            base: gasLimitDefaults === null || gasLimitDefaults === void 0 ? void 0 : gasLimitDefaults.base,
            percentIncrease: (gasLimitDefaults === null || gasLimitDefaults === void 0 ? void 0 : gasLimitDefaults.percentIncrease) ||
                defaultL1ToL2MessageEstimateOptions.gasLimitPercentIncrease,
            min: (gasLimitDefaults === null || gasLimitDefaults === void 0 ? void 0 : gasLimitDefaults.min) || ethers_1.constants.Zero,
        };
    }
    /**
     * Return the fee, in wei, of submitting a new retryable tx with a given calldata size.
     * @param l1BaseFee
     * @param callDataSize
     * @param options
     * @returns
     */
    async estimateSubmissionFee(l1Provider, l1BaseFee, callDataSize, options) {
        const defaultedOptions = this.applySubmissionPriceDefaults(options);
        const network = await (0, networks_1.getL2Network)(this.l2Provider);
        const inbox = Inbox__factory_1.Inbox__factory.connect(network.ethBridge.inbox, l1Provider);
        return this.percentIncrease(defaultedOptions.base ||
            (await inbox.calculateRetryableSubmissionFee(callDataSize, l1BaseFee)), defaultedOptions.percentIncrease);
    }
    /**
     * Estimate the amount of L2 gas required for putting the transaction in the L2 inbox, and executing it.
     * @param sender
     * @param destAddr
     * @param l2CallValue
     * @param excessFeeRefundAddress
     * @param callValueRefundAddress
     * @param calldata
     * @param senderDeposit we dont know how much gas the transaction will use when executing
     * so by default we supply a dummy amount of call value that will definately be more than we need
     * @returns
     */
    async estimateRetryableTicketGasLimit(sender, destAddr, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, calldata, senderDeposit = ethers_2.utils.parseEther('1').add(l2CallValue)) {
        const nodeInterface = NodeInterface__factory_1.NodeInterface__factory.connect(constants_1.NODE_INTERFACE_ADDRESS, this.l2Provider);
        return await nodeInterface.estimateGas.estimateRetryableTicket(sender, senderDeposit, destAddr, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, calldata);
    }
    /**
     * Get gas limit, gas price and submission price estimates for sending an L1->L2 message
     * @param sender Sender of the L1 to L2 transaction
     * @param l2CallTo Destination L2 contract address
     * @param l2CallData The hex call data to be sent in the request
     * @param l2CallValue The value to be sent on L2 as part of the L2 transaction
     * @param l1BaseFee Current l1 base fee
     * @param excessFeeRefundAddress The address to send excess fee refunds too
     * @param callValueRefundAddress The address to send the call value
     * @param options
     * @returns
     */
    async estimateAll(sender, l2CallTo, l2CallData, l2CallValue, l1BaseFee, excessFeeRefundAddress, callValueRefundAddress, l1Provider, options) {
        const gasLimitDefaults = this.applyGasLimitDefaults(options === null || options === void 0 ? void 0 : options.gasLimit);
        const maxFeePerGasDefaults = this.applyMaxFeePerGasDefaults(options === null || options === void 0 ? void 0 : options.maxFeePerGas);
        // estimate the l1 gas price
        const maxFeePerGas = this.percentIncrease(maxFeePerGasDefaults.base || (await this.l2Provider.getGasPrice()), maxFeePerGasDefaults.percentIncrease);
        // estimate the submission fee
        const maxSubmissionFee = await this.estimateSubmissionFee(l1Provider, l1BaseFee, ethers_2.utils.hexDataLength(l2CallData), options === null || options === void 0 ? void 0 : options.maxSubmissionFee);
        // estimate the gas limit
        const calculatedGasLimit = this.percentIncrease(gasLimitDefaults.base ||
            (await this.estimateRetryableTicketGasLimit(sender, l2CallTo, l2CallValue, excessFeeRefundAddress, callValueRefundAddress, l2CallData)), gasLimitDefaults.percentIncrease);
        // always ensure the max gas is greater than the min - this can be useful if we know that
        // gas estimation is bad for the provided transaction
        const gasLimit = calculatedGasLimit.gt(gasLimitDefaults.min)
            ? calculatedGasLimit
            : gasLimitDefaults.min;
        // estimate the total l2 gas costs
        const totalL2GasCosts = maxSubmissionFee.add(maxFeePerGas.mul(gasLimit));
        return {
            gasLimit,
            maxSubmissionFee,
            maxFeePerGas: maxFeePerGas,
            totalL2GasCosts,
        };
    }
}
exports.L1ToL2MessageGasEstimator = L1ToL2MessageGasEstimator;
