import { BaseContract, BigNumber, BigNumberish, BytesLike, CallOverrides, ContractTransaction, Overrides, PopulatedTransaction, Signer, utils } from "ethers";
import { FunctionFragment, Result, EventFragment } from "@ethersproject/abi";
import { Listener, Provider } from "@ethersproject/providers";
import { TypedEventFilter, TypedEvent, TypedListener, OnEvent } from "./common";
export declare namespace ISequencerInbox {
    type MaxTimeVariationStruct = {
        delayBlocks: BigNumberish;
        futureBlocks: BigNumberish;
        delaySeconds: BigNumberish;
        futureSeconds: BigNumberish;
    };
    type MaxTimeVariationStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        delayBlocks: BigNumber;
        futureBlocks: BigNumber;
        delaySeconds: BigNumber;
        futureSeconds: BigNumber;
    };
    type TimeBoundsStruct = {
        minTimestamp: BigNumberish;
        maxTimestamp: BigNumberish;
        minBlockNumber: BigNumberish;
        maxBlockNumber: BigNumberish;
    };
    type TimeBoundsStructOutput = [
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        minTimestamp: BigNumber;
        maxTimestamp: BigNumber;
        minBlockNumber: BigNumber;
        maxBlockNumber: BigNumber;
    };
}
export interface SequencerInboxStubInterface extends utils.Interface {
    contractName: "SequencerInboxStub";
    functions: {
        "DATA_AUTHENTICATED_FLAG()": FunctionFragment;
        "HEADER_LENGTH()": FunctionFragment;
        "addInitMessage()": FunctionFragment;
        "addSequencerL2Batch(uint256,bytes,uint256,address)": FunctionFragment;
        "addSequencerL2BatchFromOrigin(uint256,bytes,uint256,address)": FunctionFragment;
        "batchCount()": FunctionFragment;
        "delayedBridge()": FunctionFragment;
        "forceInclusion(uint256,uint8,uint64[2],uint256,address,bytes32)": FunctionFragment;
        "inboxAccs(uint256)": FunctionFragment;
        "initialize(address,address,(uint256,uint256,uint256,uint256))": FunctionFragment;
        "isBatchPoster(address)": FunctionFragment;
        "maxTimeVariation()": FunctionFragment;
        "rollup()": FunctionFragment;
        "setIsBatchPoster(address,bool)": FunctionFragment;
        "setMaxTimeVariation((uint256,uint256,uint256,uint256))": FunctionFragment;
        "totalDelayedMessagesRead()": FunctionFragment;
    };
    encodeFunctionData(functionFragment: "DATA_AUTHENTICATED_FLAG", values?: undefined): string;
    encodeFunctionData(functionFragment: "HEADER_LENGTH", values?: undefined): string;
    encodeFunctionData(functionFragment: "addInitMessage", values?: undefined): string;
    encodeFunctionData(functionFragment: "addSequencerL2Batch", values: [BigNumberish, BytesLike, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "addSequencerL2BatchFromOrigin", values: [BigNumberish, BytesLike, BigNumberish, string]): string;
    encodeFunctionData(functionFragment: "batchCount", values?: undefined): string;
    encodeFunctionData(functionFragment: "delayedBridge", values?: undefined): string;
    encodeFunctionData(functionFragment: "forceInclusion", values: [
        BigNumberish,
        BigNumberish,
        [
            BigNumberish,
            BigNumberish
        ],
        BigNumberish,
        string,
        BytesLike
    ]): string;
    encodeFunctionData(functionFragment: "inboxAccs", values: [BigNumberish]): string;
    encodeFunctionData(functionFragment: "initialize", values: [string, string, ISequencerInbox.MaxTimeVariationStruct]): string;
    encodeFunctionData(functionFragment: "isBatchPoster", values: [string]): string;
    encodeFunctionData(functionFragment: "maxTimeVariation", values?: undefined): string;
    encodeFunctionData(functionFragment: "rollup", values?: undefined): string;
    encodeFunctionData(functionFragment: "setIsBatchPoster", values: [string, boolean]): string;
    encodeFunctionData(functionFragment: "setMaxTimeVariation", values: [ISequencerInbox.MaxTimeVariationStruct]): string;
    encodeFunctionData(functionFragment: "totalDelayedMessagesRead", values?: undefined): string;
    decodeFunctionResult(functionFragment: "DATA_AUTHENTICATED_FLAG", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "HEADER_LENGTH", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addInitMessage", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addSequencerL2Batch", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "addSequencerL2BatchFromOrigin", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "batchCount", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "delayedBridge", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "forceInclusion", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "inboxAccs", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "initialize", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "isBatchPoster", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "maxTimeVariation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "rollup", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setIsBatchPoster", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "setMaxTimeVariation", data: BytesLike): Result;
    decodeFunctionResult(functionFragment: "totalDelayedMessagesRead", data: BytesLike): Result;
    events: {
        "SequencerBatchData(uint256,bytes)": EventFragment;
        "SequencerBatchDelivered(uint256,bytes32,bytes32,bytes32,uint256,tuple,uint8)": EventFragment;
    };
    getEvent(nameOrSignatureOrTopic: "SequencerBatchData"): EventFragment;
    getEvent(nameOrSignatureOrTopic: "SequencerBatchDelivered"): EventFragment;
}
export declare type SequencerBatchDataEvent = TypedEvent<[
    BigNumber,
    string
], {
    batchSequenceNumber: BigNumber;
    data: string;
}>;
export declare type SequencerBatchDataEventFilter = TypedEventFilter<SequencerBatchDataEvent>;
export declare type SequencerBatchDeliveredEvent = TypedEvent<[
    BigNumber,
    string,
    string,
    string,
    BigNumber,
    ISequencerInbox.TimeBoundsStructOutput,
    number
], {
    batchSequenceNumber: BigNumber;
    beforeAcc: string;
    afterAcc: string;
    delayedAcc: string;
    afterDelayedMessagesRead: BigNumber;
    timeBounds: ISequencerInbox.TimeBoundsStructOutput;
    dataLocation: number;
}>;
export declare type SequencerBatchDeliveredEventFilter = TypedEventFilter<SequencerBatchDeliveredEvent>;
export interface SequencerInboxStub extends BaseContract {
    contractName: "SequencerInboxStub";
    connect(signerOrProvider: Signer | Provider | string): this;
    attach(addressOrName: string): this;
    deployed(): Promise<this>;
    interface: SequencerInboxStubInterface;
    queryFilter<TEvent extends TypedEvent>(event: TypedEventFilter<TEvent>, fromBlockOrBlockhash?: string | number | undefined, toBlock?: string | number | undefined): Promise<Array<TEvent>>;
    listeners<TEvent extends TypedEvent>(eventFilter?: TypedEventFilter<TEvent>): Array<TypedListener<TEvent>>;
    listeners(eventName?: string): Array<Listener>;
    removeAllListeners<TEvent extends TypedEvent>(eventFilter: TypedEventFilter<TEvent>): this;
    removeAllListeners(eventName?: string): this;
    off: OnEvent<this>;
    on: OnEvent<this>;
    once: OnEvent<this>;
    removeListener: OnEvent<this>;
    functions: {
        DATA_AUTHENTICATED_FLAG(overrides?: CallOverrides): Promise<[string]>;
        HEADER_LENGTH(overrides?: CallOverrides): Promise<[BigNumber]>;
        addInitMessage(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        addSequencerL2Batch(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        addSequencerL2BatchFromOrigin(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        batchCount(overrides?: CallOverrides): Promise<[BigNumber]>;
        delayedBridge(overrides?: CallOverrides): Promise<[string]>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTime: [BigNumberish, BigNumberish], baseFeeL1: BigNumberish, sender: string, messageDataHash: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<[string]>;
        initialize(delayedBridge_: string, rollup_: string, maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        isBatchPoster(arg0: string, overrides?: CallOverrides): Promise<[boolean]>;
        maxTimeVariation(overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            delayBlocks: BigNumber;
            futureBlocks: BigNumber;
            delaySeconds: BigNumber;
            futureSeconds: BigNumber;
        }>;
        rollup(overrides?: CallOverrides): Promise<[string]>;
        setIsBatchPoster(addr: string, isBatchPoster_: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        setMaxTimeVariation(maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<ContractTransaction>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<[BigNumber]>;
    };
    DATA_AUTHENTICATED_FLAG(overrides?: CallOverrides): Promise<string>;
    HEADER_LENGTH(overrides?: CallOverrides): Promise<BigNumber>;
    addInitMessage(overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    addSequencerL2Batch(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    addSequencerL2BatchFromOrigin(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    batchCount(overrides?: CallOverrides): Promise<BigNumber>;
    delayedBridge(overrides?: CallOverrides): Promise<string>;
    forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTime: [BigNumberish, BigNumberish], baseFeeL1: BigNumberish, sender: string, messageDataHash: BytesLike, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
    initialize(delayedBridge_: string, rollup_: string, maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    isBatchPoster(arg0: string, overrides?: CallOverrides): Promise<boolean>;
    maxTimeVariation(overrides?: CallOverrides): Promise<[
        BigNumber,
        BigNumber,
        BigNumber,
        BigNumber
    ] & {
        delayBlocks: BigNumber;
        futureBlocks: BigNumber;
        delaySeconds: BigNumber;
        futureSeconds: BigNumber;
    }>;
    rollup(overrides?: CallOverrides): Promise<string>;
    setIsBatchPoster(addr: string, isBatchPoster_: boolean, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    setMaxTimeVariation(maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
        from?: string | Promise<string>;
    }): Promise<ContractTransaction>;
    totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    callStatic: {
        DATA_AUTHENTICATED_FLAG(overrides?: CallOverrides): Promise<string>;
        HEADER_LENGTH(overrides?: CallOverrides): Promise<BigNumber>;
        addInitMessage(overrides?: CallOverrides): Promise<void>;
        addSequencerL2Batch(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: CallOverrides): Promise<void>;
        addSequencerL2BatchFromOrigin(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: CallOverrides): Promise<void>;
        batchCount(overrides?: CallOverrides): Promise<BigNumber>;
        delayedBridge(overrides?: CallOverrides): Promise<string>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTime: [BigNumberish, BigNumberish], baseFeeL1: BigNumberish, sender: string, messageDataHash: BytesLike, overrides?: CallOverrides): Promise<void>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<string>;
        initialize(delayedBridge_: string, rollup_: string, maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: CallOverrides): Promise<void>;
        isBatchPoster(arg0: string, overrides?: CallOverrides): Promise<boolean>;
        maxTimeVariation(overrides?: CallOverrides): Promise<[
            BigNumber,
            BigNumber,
            BigNumber,
            BigNumber
        ] & {
            delayBlocks: BigNumber;
            futureBlocks: BigNumber;
            delaySeconds: BigNumber;
            futureSeconds: BigNumber;
        }>;
        rollup(overrides?: CallOverrides): Promise<string>;
        setIsBatchPoster(addr: string, isBatchPoster_: boolean, overrides?: CallOverrides): Promise<void>;
        setMaxTimeVariation(maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: CallOverrides): Promise<void>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    };
    filters: {
        "SequencerBatchData(uint256,bytes)"(batchSequenceNumber?: BigNumberish | null, data?: null): SequencerBatchDataEventFilter;
        SequencerBatchData(batchSequenceNumber?: BigNumberish | null, data?: null): SequencerBatchDataEventFilter;
        "SequencerBatchDelivered(uint256,bytes32,bytes32,bytes32,uint256,tuple,uint8)"(batchSequenceNumber?: BigNumberish | null, beforeAcc?: BytesLike | null, afterAcc?: BytesLike | null, delayedAcc?: null, afterDelayedMessagesRead?: null, timeBounds?: null, dataLocation?: null): SequencerBatchDeliveredEventFilter;
        SequencerBatchDelivered(batchSequenceNumber?: BigNumberish | null, beforeAcc?: BytesLike | null, afterAcc?: BytesLike | null, delayedAcc?: null, afterDelayedMessagesRead?: null, timeBounds?: null, dataLocation?: null): SequencerBatchDeliveredEventFilter;
    };
    estimateGas: {
        DATA_AUTHENTICATED_FLAG(overrides?: CallOverrides): Promise<BigNumber>;
        HEADER_LENGTH(overrides?: CallOverrides): Promise<BigNumber>;
        addInitMessage(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        addSequencerL2Batch(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        addSequencerL2BatchFromOrigin(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        batchCount(overrides?: CallOverrides): Promise<BigNumber>;
        delayedBridge(overrides?: CallOverrides): Promise<BigNumber>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTime: [BigNumberish, BigNumberish], baseFeeL1: BigNumberish, sender: string, messageDataHash: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<BigNumber>;
        initialize(delayedBridge_: string, rollup_: string, maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        isBatchPoster(arg0: string, overrides?: CallOverrides): Promise<BigNumber>;
        maxTimeVariation(overrides?: CallOverrides): Promise<BigNumber>;
        rollup(overrides?: CallOverrides): Promise<BigNumber>;
        setIsBatchPoster(addr: string, isBatchPoster_: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        setMaxTimeVariation(maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<BigNumber>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<BigNumber>;
    };
    populateTransaction: {
        DATA_AUTHENTICATED_FLAG(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        HEADER_LENGTH(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        addInitMessage(overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        addSequencerL2Batch(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        addSequencerL2BatchFromOrigin(sequenceNumber: BigNumberish, data: BytesLike, afterDelayedMessagesRead: BigNumberish, gasRefunder: string, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        batchCount(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        delayedBridge(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        forceInclusion(_totalDelayedMessagesRead: BigNumberish, kind: BigNumberish, l1BlockAndTime: [BigNumberish, BigNumberish], baseFeeL1: BigNumberish, sender: string, messageDataHash: BytesLike, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        inboxAccs(arg0: BigNumberish, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        initialize(delayedBridge_: string, rollup_: string, maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        isBatchPoster(arg0: string, overrides?: CallOverrides): Promise<PopulatedTransaction>;
        maxTimeVariation(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        rollup(overrides?: CallOverrides): Promise<PopulatedTransaction>;
        setIsBatchPoster(addr: string, isBatchPoster_: boolean, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        setMaxTimeVariation(maxTimeVariation_: ISequencerInbox.MaxTimeVariationStruct, overrides?: Overrides & {
            from?: string | Promise<string>;
        }): Promise<PopulatedTransaction>;
        totalDelayedMessagesRead(overrides?: CallOverrides): Promise<PopulatedTransaction>;
    };
}
