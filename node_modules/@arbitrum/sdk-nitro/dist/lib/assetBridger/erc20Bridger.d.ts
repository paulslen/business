import { Signer } from '@ethersproject/abstract-signer';
import { Provider, BlockTag } from '@ethersproject/abstract-provider';
import { PayableOverrides, Overrides } from '@ethersproject/contracts';
import { BigNumber, ethers } from 'ethers';
import { ERC20 } from '../abi/ERC20';
import { L2GatewayToken } from '../abi/L2GatewayToken';
import { WithdrawalInitiatedEvent } from '../abi/L2ArbitrumGateway';
import { GatewaySetEvent } from '../abi/L1GatewayRouter';
import { GasOverrides } from '../message/L1ToL2MessageGasEstimator';
import { L2Network } from '../dataEntities/networks';
import { EthDepositParams, EthWithdrawParams } from './ethBridger';
import { AssetBridger } from './assetBridger';
import { L1ContractCallTransaction, L1ContractTransaction } from '../message/L1Transaction';
import { L2ContractTransaction } from '../message/L2Transaction';
export interface TokenApproveParams {
    /**
     * L1 signer whose tokens are being approved
     */
    l1Signer: Signer;
    /**
     * L1 address of the ERC20 token contract
     */
    erc20L1Address: string;
    /**
     * Amount to approve. Defaults to max int.
     */
    amount?: BigNumber;
    /**
     * Transaction overrides
     */
    overrides?: PayableOverrides;
}
export interface TokenDepositParams extends EthDepositParams {
    /**
     * An L2 provider
     */
    l2Provider: Provider;
    /**
     * L1 address of the token ERC20 contract
     */
    erc20L1Address: string;
    /**
     * L2 address of the entity receiving the funds. Defaults to the l1FromAddress
     */
    destinationAddress?: string;
    /**
     * Overrides for the retryable ticket parameters
     */
    retryableGasOverrides?: GasOverrides;
    /**
     * Transaction overrides
     */
    overrides?: Overrides;
}
export interface TokenWithdrawParams extends EthWithdrawParams {
    /**
     * L1 address of the token ERC20 contract
     */
    erc20l1Address: string;
}
/**
 * Bridger for moving ERC20 tokens back and forth betwen L1 to L2
 */
export declare class Erc20Bridger extends AssetBridger<TokenDepositParams, TokenWithdrawParams> {
    static MAX_APPROVAL: BigNumber;
    static MIN_CUSTOM_DEPOSIT_GAS_LIMIT: BigNumber;
    /**
     * Bridger for moving ERC20 tokens back and forth betwen L1 to L2
     */
    constructor(l2Network: L2Network);
    /**
     * Get the address of the l1 gateway for this token
     * @param erc20L1Address
     * @param l1Provider
     * @returns
     */
    getL1GatewayAddress(erc20L1Address: string, l1Provider: Provider): Promise<string>;
    /**
     * Get the address of the l2 gateway for this token
     * @param erc20L1Address
     * @param l2Provider
     * @returns
     */
    getL2GatewayAddress(erc20L1Address: string, l2Provider: Provider): Promise<string>;
    /**
     * Approve tokens for deposit to the bridge. The tokens will be approved for the relevant gateway.
     * @param params
     * @returns
     */
    approveToken(params: TokenApproveParams): Promise<ethers.ContractTransaction>;
    /**
     * Get the L2 events created by a withdrawal
     * @param l2Provider
     * @param gatewayAddress
     * @param l1TokenAddress
     * @param fromAddress
     * @param filter
     * @returns
     */
    getL2WithdrawalEvents(l2Provider: Provider, gatewayAddress: string, filter: {
        fromBlock: BlockTag;
        toBlock: BlockTag;
    }, l1TokenAddress?: string, fromAddress?: string): Promise<(WithdrawalInitiatedEvent['args'] & {
        txHash: string;
    })[]>;
    /**
     * Does the provided address look like a weth gateway
     * @param potentialWethGatewayAddress
     * @param l1Provider
     * @returns
     */
    private looksLikeWethGateway;
    /**
     * Is this a known or unknown WETH gateway
     * @param gatewayAddress
     * @param l1Provider
     * @returns
     */
    private isWethGateway;
    /**
     * Get the L2 token contract at the provided address
     * @param l2Provider
     * @param l2TokenAddr
     * @returns
     */
    getL2TokenContract(l2Provider: Provider, l2TokenAddr: string): L2GatewayToken;
    /**
     * Get the L1 token contract at the provided address
     * @param l1Provider
     * @param l1TokenAddr
     * @returns
     */
    getL1TokenContract(l1Provider: Provider, l1TokenAddr: string): ERC20;
    /**
     * Get the corresponding L2 for the provided L1 token
     * @param erc20L1Address
     * @param l1Provider
     * @returns
     */
    getL2ERC20Address(erc20L1Address: string, l1Provider: Provider): Promise<string>;
    /**
     * Get the corresponding L1 for the provided L2 token
     * @param erc20L1Address
     * @param l1Provider
     * @returns
     */
    getL1ERC20Address(erc20L2Address: string, l2Provider: Provider): Promise<string>;
    /**
     * Whether the token has been disabled on the router
     * @param l1TokenAddress
     * @param l1Provider
     * @returns
     */
    l1TokenIsDisabled(l1TokenAddress: string, l1Provider: Provider): Promise<boolean>;
    private validateDepositParams;
    getDepositParams(params: TokenDepositParams): Promise<{
        erc20L1Address: string;
        amount: BigNumber;
        depositCallValue: BigNumber;
        maxSubmissionFee: BigNumber;
        data: string;
        l2GasLimit: BigNumber;
        l2MaxFeePerGas: BigNumber;
        destinationAddress: string;
        retryableCallData: string;
        retryableSender: string;
        retryableDestination: string;
        retryableExcessFeeRefundAddress: string;
        retryableCallValueRefundAddress: string;
        retryableValue: BigNumber;
    }>;
    private depositTxOrGas;
    /**
     * Estimate the gas required for a token deposit
     * @param params
     * @returns
     */
    depositEstimateGas(params: TokenDepositParams): Promise<BigNumber>;
    /**
     * Execute a token deposit from L1 to L2
     * @param params
     * @returns
     */
    deposit(params: TokenDepositParams): Promise<L1ContractCallTransaction>;
    private withdrawTxOrGas;
    /**
     * Estimate gas for withdrawing tokens from L2 to L1
     * @param params
     * @returns
     */
    withdrawEstimateGas(params: TokenWithdrawParams): Promise<BigNumber>;
    /**
     * Withdraw tokens from L2 to L1
     * @param params
     * @returns
     */
    withdraw(params: TokenWithdrawParams): Promise<L2ContractTransaction>;
}
/**
 * A token and gateway pair
 */
interface TokenAndGateway {
    tokenAddr: string;
    gatewayAddr: string;
}
/**
 * Admin functionality for the token bridge
 */
export declare class AdminErc20Bridger extends Erc20Bridger {
    /**
     * Register a custom token on the Arbitrum bridge
     * See https://developer.offchainlabs.com/docs/bridging_assets#the-arbitrum-generic-custom-gateway for more details
     * @param l1TokenAddress Address of the already deployed l1 token. Must inherit from https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-peripherals/tokenbridge/ethereum/icustomtoken.
     * @param l2TokenAddress Address of the already deployed l2 token. Must inherit from https://developer.offchainlabs.com/docs/sol_contract_docs/md_docs/arb-bridge-peripherals/tokenbridge/arbitrum/iarbtoken.
     * @param l1Signer The signer with the rights to call registerTokenOnL2 on the l1 token
     * @param l2Provider Arbitrum rpc provider
     * @returns
     */
    registerCustomToken(l1TokenAddress: string, l2TokenAddress: string, l1Signer: Signer, l2Provider: Provider): Promise<L1ContractTransaction>;
    /**
     * Get all the gateway set events on the L1 gateway router
     * @param l1Provider
     * @param customNetworkL1GatewayRouter
     * @returns
     */
    getL1GatewaySetEvents(l1Provider: Provider, filter: {
        fromBlock: BlockTag;
        toBlock: BlockTag;
    }): Promise<GatewaySetEvent['args'][]>;
    /**
     * Get all the gateway set events on the L2 gateway router
     * @param l1Provider
     * @param customNetworkL1GatewayRouter
     * @returns
     */
    getL2GatewaySetEvents(l2Provider: Provider, filter: {
        fromBlock: BlockTag;
        toBlock: BlockTag;
    }, customNetworkL2GatewayRouter?: string): Promise<GatewaySetEvent['args'][]>;
    /**
     * Register the provided token addresses against the provided gateways
     * @param l1Signer
     * @param l2Provider
     * @param tokenGateways
     * @returns
     */
    setGateways(l1Signer: Signer, l2Provider: Provider, tokenGateways: TokenAndGateway[]): Promise<L1ContractCallTransaction>;
}
export {};
