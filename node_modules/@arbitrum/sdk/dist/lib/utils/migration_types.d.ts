import * as classic from '@arbitrum/sdk-classic';
import * as nitro from '@arbitrum/sdk-nitro';
import { BigNumber, ContractTransaction, ethers, Overrides } from 'ethers';
import { GasOverrides as ClassicGasOverrides } from '@arbitrum/sdk-classic/dist/lib/message/L1ToL2MessageGasEstimator';
import { GasOverrides as NitroGasOverrides } from '@arbitrum/sdk-nitro/dist/lib/message/L1ToL2MessageGasEstimator';
import { Provider } from '@ethersproject/abstract-provider';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { L1ToL2MessageStatus, L1ToL2MessageWaitResult } from '../message/L1ToL2Message';
import { L2ToL1MessageStatus } from '../message/L2ToL1Message';
import { MessageDeliveredEvent as ClassicMessageDeliveredEvent } from '@arbitrum/sdk-classic/dist/lib/abi/Bridge';
import { FetchedEvent } from './eventFetcher';
import { L2Network as NitroL2Network } from '@arbitrum/sdk-nitro';
import { L1ToL2MessageReader as ClassicL1ToL2MessageReader } from '@arbitrum/sdk-classic/dist/index';
export declare const generateL2NitroNetwork: (existingNitroL2Network: nitro.L2Network, l1Provider: Provider) => Promise<NitroL2Network>;
/**
 * New outboxes can be added to the bridge, and withdrawals always use the latest outbox.
 * This function finds the outbox address for a supplied batch number
 * @param network
 * @param batchNumber
 * @returns
 */
export declare const getOutboxAddr: (network: classic.L2Network, batchNumber: number) => string;
export declare const isNitroL1: (l1Provider: SignerOrProvider) => Promise<boolean>;
export declare const isNitroL2: (l2SignerOrProvider: SignerOrProvider) => Promise<boolean>;
export declare const lookupExistingNetwork: (l2Network: nitro.L2Network) => classic.L2Network;
export declare const convertNetworkNitroToClassic: (l2Network: nitro.L2Network) => classic.L2Network;
export declare const convertNetworkClassicToNitro: (l2Network: classic.L2Network) => nitro.L2Network;
export declare const convertGasOverrides: (gasOverrides?: NitroGasOverrides) => Omit<ClassicGasOverrides, 'sendL2CallValueFromL1'>;
export declare const convertEstimates: (estimates: {
    maxGasBid: BigNumber;
    maxSubmissionPriceBid: BigNumber;
    maxGasPriceBid: BigNumber;
    totalDepositValue: BigNumber;
}) => {
    gasLimit: BigNumber;
    maxSubmissionFee: BigNumber;
    maxFeePerGas: BigNumber;
    totalL2GasCosts: BigNumber;
};
export declare const convertL2ToL1Status: (status: classic.L2ToL1MessageStatus) => nitro.L2ToL1MessageStatus;
export interface IL1ToL2MessageReader {
    readonly retryableCreationId: string;
    isExpired(): Promise<boolean>;
    status(): Promise<L1ToL2MessageStatus>;
    waitForStatus(confirmations?: number, timeout?: number): Promise<L1ToL2MessageWaitResult>;
    getTimeout(): Promise<BigNumber>;
    getBeneficiary(): Promise<string>;
}
export interface IL1ToL2MessageWriter extends IL1ToL2MessageReader {
    redeem(overrides?: Overrides): Promise<ContractTransaction>;
    cancel(overrides?: Overrides): Promise<ContractTransaction>;
}
export declare type IL1ToL2MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? IL1ToL2MessageReader : IL1ToL2MessageWriter;
export declare type IL2ToL1MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? IL2ToL1MessageReader : IL2ToL1MessageWriter;
export interface IL2ToL1MessageReader {
    getOutboxProof(l2Provider: Provider): Promise<MessageBatchProofInfo | null | string[]>;
    status(l2Provider: Provider): Promise<L2ToL1MessageStatus>;
    waitUntilReadyToExecute(l2Provider: Provider, retryDelay?: number): Promise<void>;
    getFirstExecutableBlock(l2Provider: Provider): Promise<BigNumber | null>;
}
export interface IL2ToL1MessageWriter extends IL2ToL1MessageReader {
    execute(l2Provider: Provider, overrides?: Overrides): Promise<ContractTransaction>;
}
export interface MessageBatchProofInfo {
    /**
     * Merkle proof of message inclusion in outbox entry
     */
    proof: string[];
    /**
     * Merkle path to message
     */
    path: BigNumber;
    /**
     * Sender of original message (i.e., caller of ArbSys.sendTxToL1)
     */
    l2Sender: string;
    /**
     * Destination address for L1 contract call
     */
    l1Dest: string;
    /**
     * L2 block number at which sendTxToL1 call was made
     */
    l2Block: BigNumber;
    /**
     * L1 block number at which sendTxToL1 call was made
     */
    l1Block: BigNumber;
    /**
     * L2 Timestamp at which sendTxToL1 call was made
     */
    timestamp: BigNumber;
    /**
     * Value in L1 message in wei
     */
    amount: BigNumber;
    /**
     * ABI-encoded L1 message data
     */
    calldataForL1: string;
}
export { ClassicMessageDeliveredEvent };
export declare type ClassicForceInclusionParams = FetchedEvent<ClassicMessageDeliveredEvent> & {
    delayedAcc: string;
};
/**
 * Nitro compatible EthDepositMessage
 */
export interface EthDepositMessage {
    readonly l2ChainId: number;
    readonly messageNumber: BigNumber;
    readonly to: string;
    readonly value: BigNumber;
    readonly l2DepositTxHash: string;
    wait(confirmations?: number, timeout?: number): Promise<ethers.providers.TransactionReceipt | null>;
}
export declare const toNitroEthDepositMessage: (message: ClassicL1ToL2MessageReader, l2ChainId: number) => Promise<EthDepositMessage>;
