"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.toNitroEthDepositMessage = exports.convertL2ToL1Status = exports.convertEstimates = exports.convertGasOverrides = exports.convertNetworkClassicToNitro = exports.convertNetworkNitroToClassic = exports.lookupExistingNetwork = exports.isNitroL2 = exports.isNitroL1 = exports.getOutboxAddr = exports.generateL2NitroNetwork = void 0;
const classic = __importStar(require("@arbitrum/sdk-classic"));
const nitro = __importStar(require("@arbitrum/sdk-nitro"));
const ethers_1 = require("ethers");
const providers_1 = require("@ethersproject/providers");
const constants_1 = require("../dataEntities/constants");
const ArbSys__factory_1 = require("../abi/factories/ArbSys__factory");
const Bridge__factory_1 = require("../abi/factories/Bridge__factory");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const L1ToL2Message_1 = require("../message/L1ToL2Message");
const Inbox__factory_1 = require("@arbitrum/sdk-nitro/dist/lib/abi/factories/Inbox__factory");
const Bridge__factory_2 = require("@arbitrum/sdk-nitro/dist/lib/abi/factories/Bridge__factory");
const RollupUserLogic__factory_1 = require("@arbitrum/sdk-nitro/dist/lib/abi/factories/RollupUserLogic__factory");
const networks_1 = require("@arbitrum/sdk-classic/dist/lib/dataEntities/networks");
const networks_2 = require("@arbitrum/sdk-nitro/dist/lib/dataEntities/networks");
const errors_1 = require("../dataEntities/errors");
let isNitro = false;
const generateL2NitroNetwork = async (existingNitroL2Network, l1Provider) => {
    // we know the inbox hasnt changed
    const inboxAddr = existingNitroL2Network.ethBridge.inbox;
    const inbox = Inbox__factory_1.Inbox__factory.connect(inboxAddr, l1Provider);
    const bridgeAddr = await inbox.bridge();
    // the rollup is the bridge owner
    const bridge = Bridge__factory_2.Bridge__factory.connect(bridgeAddr, l1Provider);
    const rollupAddr = await bridge.owner();
    const rollup = RollupUserLogic__factory_1.RollupUserLogic__factory.connect(rollupAddr, l1Provider);
    const sequencerInboxAddr = await rollup.sequencerBridge();
    const outboxAddr = await rollup.outbox();
    return {
        chainID: existingNitroL2Network.chainID,
        confirmPeriodBlocks: existingNitroL2Network.confirmPeriodBlocks,
        ethBridge: {
            inbox: inboxAddr,
            bridge: bridgeAddr,
            outbox: outboxAddr,
            rollup: rollupAddr,
            sequencerInbox: sequencerInboxAddr,
        },
        explorerUrl: existingNitroL2Network.explorerUrl,
        isArbitrum: existingNitroL2Network.isArbitrum,
        isCustom: existingNitroL2Network.isCustom,
        name: existingNitroL2Network.name,
        partnerChainID: existingNitroL2Network.partnerChainID,
        retryableLifetimeSeconds: existingNitroL2Network.retryableLifetimeSeconds,
        rpcURL: existingNitroL2Network.rpcURL,
        tokenBridge: existingNitroL2Network.tokenBridge,
        gif: existingNitroL2Network.gif,
    };
};
exports.generateL2NitroNetwork = generateL2NitroNetwork;
/**
 * New outboxes can be added to the bridge, and withdrawals always use the latest outbox.
 * This function finds the outbox address for a supplied batch number
 * @param network
 * @param batchNumber
 * @returns
 */
const getOutboxAddr = (network, batchNumber) => {
    // find the outbox where the activation batch number of the next outbox
    // is greater than the supplied batch
    const res = Object.entries(network.ethBridge.outboxes)
        .sort((a, b) => {
        if (a[1] < b[1])
            return -1;
        else if (a[1] === b[1])
            return 0;
        else
            return 1;
    })
        .find((_, index, array) => array[index + 1] === undefined || array[index + 1][1].gt(batchNumber));
    if (!res) {
        throw new errors_1.ArbSdkError(`No outbox found for batch number: ${batchNumber} on network: ${network.chainID}.`);
    }
    return res[0];
};
exports.getOutboxAddr = getOutboxAddr;
const fifthteenMinutesMs = 15 * 60 * 1000;
const lastUpdatedL1 = {
    timestamp: 0,
    value: false,
};
const lastUpdatedL2 = {
    timestamp: 0,
    value: false,
};
const isNitroL1 = async (l1Provider) => {
    if (isNitro)
        return true;
    if (Date.now() - lastUpdatedL1.timestamp > fifthteenMinutesMs) {
        const l1Network = await nitro.getL1Network(l1Provider);
        const partner = l1Network.partnerChainIDs[0];
        const l2Network = await nitro.getL2Network(partner);
        if (!l2Network)
            throw new errors_1.ArbSdkError(`No l2 network found with chain id ${partner}`);
        try {
            const inboxAddr = l2Network.ethBridge.inbox;
            const inbox = Inbox__factory_1.Inbox__factory.connect(inboxAddr, l1Provider);
            const bridgeAddr = await inbox.bridge();
            const bridge = Bridge__factory_1.Bridge__factory.connect(bridgeAddr, l1Provider);
            const rollupAdd = await bridge.owner();
            const rollup = RollupUserLogic__factory_1.RollupUserLogic__factory.connect(rollupAdd, l1Provider);
            // this will error if we're not nitro
            await rollup.wasmModuleRoot();
            // when we've switched to nitro we need to regenerate the nitro
            // network config and set it
            const nitroL2Network = await (0, exports.generateL2NitroNetwork)(l2Network, signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(l1Provider));
            networks_2.l2Networks[nitroL2Network.chainID] = nitroL2Network;
            isNitro = true;
            lastUpdatedL1.timestamp = Date.now();
            lastUpdatedL1.value = true;
        }
        catch (err) {
            lastUpdatedL1.timestamp = Date.now();
            lastUpdatedL1.value = false;
        }
    }
    return lastUpdatedL1.value;
};
exports.isNitroL1 = isNitroL1;
const isNitroL2 = async (l2SignerOrProvider) => {
    if (isNitro)
        return true;
    if (Date.now() - lastUpdatedL2.timestamp > fifthteenMinutesMs) {
        const arbSys = ArbSys__factory_1.ArbSys__factory.connect(constants_1.ARB_SYS_ADDRESS, l2SignerOrProvider);
        const l2Network = await nitro.getL2Network(l2SignerOrProvider);
        const blockNumber = await arbSys.arbBlockNumber();
        try {
            // will throw an error if pre nitro
            await arbSys.arbBlockHash(blockNumber.sub(1));
            const l1Network = await nitro.getL1Network(l2Network.partnerChainID);
            const l1Provider = new providers_1.JsonRpcProvider(l1Network.rpcURL);
            // when we've switched to nitro we need to regenerate the nitro
            // network config and set it
            const nitroL2Network = await (0, exports.generateL2NitroNetwork)(l2Network, signerOrProvider_1.SignerProviderUtils.getProviderOrThrow(l1Provider));
            networks_2.l2Networks[nitroL2Network.chainID] = nitroL2Network;
            isNitro = true;
            lastUpdatedL2.timestamp = Date.now();
            lastUpdatedL2.value = true;
        }
        catch (_a) {
            lastUpdatedL2.timestamp = Date.now();
            lastUpdatedL2.value = false;
        }
    }
    return lastUpdatedL2.value;
};
exports.isNitroL2 = isNitroL2;
const lookupExistingNetwork = (l2Network) => {
    const classicNetwork = networks_1.l2Networks[l2Network.chainID];
    if (!classicNetwork) {
        throw new errors_1.ArbSdkError(`Unexpected missing classic network for chain ${l2Network.chainID}`);
    }
    return classicNetwork;
};
exports.lookupExistingNetwork = lookupExistingNetwork;
const convertNetworkNitroToClassic = (l2Network) => {
    return Object.assign(Object.assign({}, l2Network), { ethBridge: Object.assign(Object.assign({}, l2Network.ethBridge), { outboxes: {
                [l2Network.ethBridge.outbox]: ethers_1.BigNumber.from(0),
            } }) });
};
exports.convertNetworkNitroToClassic = convertNetworkNitroToClassic;
const convertNetworkClassicToNitro = (l2Network) => {
    const outboxes = Object.keys(l2Network.ethBridge.outboxes);
    return Object.assign(Object.assign({}, l2Network), { ethBridge: Object.assign(Object.assign({}, l2Network.ethBridge), { outbox: outboxes[outboxes.length - 1] }), retryableLifetimeSeconds: constants_1.SEVEN_DAYS_IN_SECONDS });
};
exports.convertNetworkClassicToNitro = convertNetworkClassicToNitro;
const convertGasOverrides = (gasOverrides) => {
    return {
        maxGas: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.gasLimit,
        maxSubmissionPrice: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.maxSubmissionFee,
        maxGasPrice: gasOverrides === null || gasOverrides === void 0 ? void 0 : gasOverrides.maxFeePerGas,
    };
};
exports.convertGasOverrides = convertGasOverrides;
const convertEstimates = (estimates) => {
    return {
        gasLimit: estimates.maxGasBid,
        maxSubmissionFee: estimates.maxSubmissionPriceBid,
        maxFeePerGas: estimates.maxGasPriceBid,
        totalL2GasCosts: estimates.maxGasPriceBid
            .mul(estimates.maxGasBid)
            .add(estimates.maxSubmissionPriceBid),
    };
};
exports.convertEstimates = convertEstimates;
const convertL2ToL1Status = (status) => {
    switch (status) {
        case classic.L2ToL1MessageStatus.CONFIRMED:
            return nitro.L2ToL1MessageStatus.CONFIRMED;
        case classic.L2ToL1MessageStatus.EXECUTED:
            return nitro.L2ToL1MessageStatus.EXECUTED;
        case classic.L2ToL1MessageStatus.NOT_FOUND:
            return nitro.L2ToL1MessageStatus.UNCONFIRMED;
        case classic.L2ToL1MessageStatus.UNCONFIRMED:
            return nitro.L2ToL1MessageStatus.UNCONFIRMED;
    }
};
exports.convertL2ToL1Status = convertL2ToL1Status;
const toNitroEthDepositMessage = async (message, l2ChainId) => {
    const inputs = await message.getInputs();
    return {
        l2ChainId: l2ChainId,
        l2DepositTxHash: message.l2TxHash,
        messageNumber: message.messageNumber,
        to: inputs.destinationAddress,
        value: inputs.l2CallValue,
        wait: async (confirmations, timeout) => {
            const statusRes = await message.waitForStatus(confirmations, timeout);
            if (statusRes.status === L1ToL2Message_1.L1ToL2MessageStatus.FUNDS_DEPOSITED_ON_L2) {
                return await message.getRetryableCreationReceipt();
            }
            else
                return null;
        },
    };
};
exports.toNitroEthDepositMessage = toNitroEthDepositMessage;
