import { TransactionReceipt } from '@ethersproject/providers';
import { Provider } from '@ethersproject/abstract-provider';
import { Signer } from '@ethersproject/abstract-signer';
import { ContractTransaction } from '@ethersproject/contracts';
import { BigNumber } from '@ethersproject/bignumber';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { Overrides } from 'ethers';
import { RetryableMessageParams } from '../dataEntities/message';
import { IL1ToL2MessageReader, IL1ToL2MessageWriter } from '../utils/migration_types';
export declare enum L2TxnType {
    L2_TX = 0,
    AUTO_REDEEM = 1
}
export declare enum L1ToL2MessageStatus {
    /**
     * The retryable ticket has yet to be created
     */
    NOT_YET_CREATED = 1,
    /**
     * An attempt was made to create the retryable ticket, but it failed.
     * This could be due to not enough submission cost being paid by the L1 transaction
     */
    CREATION_FAILED = 2,
    /**
     * The retryable ticket has been created but has not been redeemed. This could be due to the
     * auto redeem failing, or if the params (max l2 gas price) * (max l2 gas) = 0 then no auto
     * redeem tx is ever issued. An auto redeem is also never issued for ETH deposits.
     * A manual redeem is now required.
     */
    FUNDS_DEPOSITED_ON_L2 = 3,
    /**
     * The retryable ticket has been redeemed (either by auto, or manually) and the
     * l2 transaction has been executed
     */
    REDEEMED = 4,
    /**
     * The message has either expired or has been canceled. It can no longer be redeemed.
     */
    EXPIRED = 5
}
/**
 * Conditional type for Signer or Provider. If T is of type Provider
 * then L1ToL2MessageReaderOrWriter<T> will be of type L1ToL2MessageReader.
 * If T is of type Signer then L1ToL2MessageReaderOrWriter<T> will be of
 * type L1ToL2MessageWriter.
 */
export declare type L1ToL2MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? L1ToL2MessageReader : L1ToL2MessageWriter;
export declare abstract class L1ToL2Message {
    static fromTxComponents<T extends SignerOrProvider>(l2SignerOrProvider: T, chainId: number, sender: string, messageNumber: BigNumber, l1BaseFee: BigNumber, messageData: RetryableMessageParams): L1ToL2MessageReaderOrWriter<T>;
}
/**
 * If the status is redeemed an l2TxReceipt is populated.
 * For all other statuses l2TxReceipt is not populated
 */
export declare type L1ToL2MessageWaitResult = {
    status: L1ToL2MessageStatus.REDEEMED;
    l2TxReceipt: TransactionReceipt;
} | {
    status: Exclude<L1ToL2MessageStatus, L1ToL2MessageStatus.REDEEMED>;
};
export declare class L1ToL2MessageReader extends L1ToL2Message implements IL1ToL2MessageReader {
    readonly l2Provider: Provider;
    private readonly classicReader?;
    private readonly nitroReader?;
    /**
     * When messages are sent from L1 to L2 a retryable ticket is created on L2.
     * The retryableCreationId can be used to retrieve information about the success or failure of the
     * creation of the retryable ticket.
     */
    readonly retryableCreationId: string;
    constructor(l2Provider: Provider, chainId?: number, sender?: string, messageNumber?: BigNumber, l1BaseFee?: BigNumber, messageData?: RetryableMessageParams, retryableCreationId?: string);
    /**
     * Has this message expired. Once expired the retryable ticket can no longer be redeemed.
     * @returns
     */
    isExpired(): Promise<boolean>;
    status(): Promise<L1ToL2MessageStatus>;
    /**
     * Wait for the retryable ticket to be created, for it to be redeemed, and for the l2Tx to be executed.
     * Note: The terminal status of a transaction that only does an eth deposit is FUNDS_DEPOSITED_ON_L2 as
     * no L2 transaction needs to be executed, however the terminal state of any other transaction is REDEEMED
     * which represents that the retryable ticket has been redeemed and the L2 tx has been executed.
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains a status, and optionally the l2TxReceipt.
     * If the status is "REDEEMED" then a l2TxReceipt is also available on the result.
     * If the status has any other value then l2TxReceipt is not populated.
     */
    waitForStatus(confirmations?: number, timeout?: number): Promise<L1ToL2MessageWaitResult>;
    /**
     * How long until this message expires
     * @returns
     */
    getTimeout(): Promise<BigNumber>;
    /**
     * Address to which CallValue will be credited to on L2 if the retryable ticket times out or is cancelled.
     * The Beneficiary is also the address with the right to cancel a Retryable Ticket (if the ticket hasnâ€™t been redeemed yet).
     * @returns
     */
    getBeneficiary(): Promise<string>;
}
export declare class L1ToL2MessageWriter extends L1ToL2MessageReader implements IL1ToL2MessageWriter {
    readonly l2Signer: Signer;
    private readonly nitroWriter?;
    private readonly classicWriter?;
    constructor(l2Signer: Signer, chainId?: number, sender?: string, messageNumber?: BigNumber, l1BaseFee?: BigNumber, messageData?: RetryableMessageParams, retryableCreationId?: string);
    /**
     * Manually redeem the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    redeem(overrides?: Overrides): Promise<ContractTransaction>;
    /**
     * Cancel the retryable ticket.
     * Throws if message status is not L1ToL2MessageStatus.NOT_YET_REDEEMED
     */
    cancel(overrides?: Overrides): Promise<ContractTransaction>;
}
