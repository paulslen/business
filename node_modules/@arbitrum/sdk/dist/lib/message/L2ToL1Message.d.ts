import { Provider } from '@ethersproject/abstract-provider';
import { Signer } from '@ethersproject/abstract-signer';
import { BigNumber } from '@ethersproject/bignumber';
import { BlockTag } from '@ethersproject/abstract-provider';
import { ContractTransaction, Overrides } from 'ethers';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { L2ToL1TransactionEvent as ClassicL2ToL1TransactionEvent } from '@arbitrum/sdk-classic/dist/lib/abi/ArbSys';
import { L2ToL1TxEvent as NitroL2ToL1TransactionEvent } from '@arbitrum/sdk-nitro/dist/lib/abi/ArbSys';
import { IL2ToL1MessageReader, IL2ToL1MessageWriter, MessageBatchProofInfo } from '../utils/migration_types';
export declare type L2ToL1TransactionEvent = ClassicL2ToL1TransactionEvent['args'] | NitroL2ToL1TransactionEvent['args'];
export declare enum L2ToL1MessageStatus {
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    UNCONFIRMED = 1,
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    CONFIRMED = 2,
    /**
     * Outgoing message executed (terminal state)
     */
    EXECUTED = 3
}
/**
 * Conditional type for Signer or Provider. If T is of type Provider
 * then L2ToL1MessageReaderOrWriter<T> will be of type L2ToL1MessageReader.
 * If T is of type Signer then L2ToL1MessageReaderOrWriter<T> will be of
 * type L2ToL1MessageWriter.
 */
export declare type L2ToL1MessageReaderOrWriter<T extends SignerOrProvider> = T extends Provider ? L2ToL1MessageReader : L2ToL1MessageWriter;
/**
 * Base functionality for L2->L1 messages
 */
export declare class L2ToL1Message {
    protected isClassic(e: L2ToL1TransactionEvent): e is ClassicL2ToL1TransactionEvent['args'];
    static fromEvent<T extends SignerOrProvider>(l1SignerOrProvider: T, event: NitroL2ToL1TransactionEvent['args']): L2ToL1MessageReaderOrWriter<T>;
    static fromEvent<T extends SignerOrProvider>(l1SignerOrProvider: T, event: ClassicL2ToL1TransactionEvent['args'], outboxAddress: string): L2ToL1MessageReaderOrWriter<T>;
    static fromEvent<T extends SignerOrProvider>(l1SignerOrProvider: T, event: L2ToL1TransactionEvent, outboxAddress?: string): L2ToL1MessageReaderOrWriter<T>;
    /**
     * Get event logs for L2ToL1 transactions.
     * @param l2Provider
     * @param filter Block range filter
     * @param positionOrBatchNumber The batchnumber indexed field was removed in nitro and a position indexed field was added.
     * For pre-nitro events the value passed in here will be used to find events with the same batchnumber.
     * For post nitro events it will be used to find events with the same position.
     * @param destination The L1 destination of the L2ToL1 message
     * @param hashOrUniqueId The uniqueId indexed field was removed in nitro and a hash indexed field was added.
     * For pre-nitro events the value passed in here will be used to find events with the same uniqueId.
     * For post nitro events it will be used to find events with the same hash.
     * @param indexInBatch The index in the batch, only valid for pre-nitro events. This parameter is ignored post-nitro
     * @returns Any classic and nitro events that match the provided filters.
     */
    static getEventLogs(l2Provider: Provider, filter: {
        fromBlock: BlockTag;
        toBlock: BlockTag;
    }, positionOrBatchNumber?: BigNumber, destination?: string, hashOrUniqueId?: BigNumber, indexInBatch?: BigNumber): Promise<L2ToL1TransactionEvent[]>;
}
/**
 * Provides read-only access for l2-to-l1-messages
 */
export declare class L2ToL1MessageReader extends L2ToL1Message implements IL2ToL1MessageReader {
    protected readonly l1Provider: Provider;
    protected readonly outboxAddress?: string | undefined;
    private readonly classicReader?;
    private readonly nitroReader?;
    constructor(l1Provider: Provider, event: NitroL2ToL1TransactionEvent['args']);
    constructor(l1Provider: Provider, event: ClassicL2ToL1TransactionEvent['args'], outboxAddress: string);
    constructor(l1Provider: Provider, event: L2ToL1TransactionEvent, outboxAddress?: string);
    protected tryGetClassicProof(l2Provider: Provider): Promise<MessageBatchProofInfo | null>;
    getOutboxProof(l2Provider: Provider): Promise<MessageBatchProofInfo | null | string[]>;
    protected classicProof?: MessageBatchProofInfo;
    /**
     * Get the status of this message
     * In order to check if the message has been executed proof info must be provided.
     * @returns
     */
    status(l2Provider: Provider): Promise<L2ToL1MessageStatus>;
    /**
     * Waits until the outbox entry has been created, and will not return until it has been.
     * WARNING: Outbox entries are only created when the corresponding node is confirmed. Which
     * can take 1 week+, so waiting here could be a very long operation.
     * @param retryDelay
     * @returns
     */
    waitUntilReadyToExecute(l2Provider: Provider, retryDelay?: number): Promise<void>;
    /**
     * Estimates the L1 block number in which this L2 to L1 tx will be available for execution.
     * If the message can or already has been executed, this returns null
     * @param l2Provider
     * @returns expected L1 block number where the L2 to L1 message will be executable. Returns null if the message can or already has been executed
     */
    getFirstExecutableBlock(l2Provider: Provider): Promise<BigNumber | null>;
}
/**
 * Provides read and write access for l2-to-l1-messages
 */
export declare class L2ToL1MessageWriter extends L2ToL1MessageReader implements IL2ToL1MessageWriter {
    private readonly classicWriter?;
    private readonly nitroWriter?;
    constructor(l1Signer: Signer, event: NitroL2ToL1TransactionEvent['args']);
    constructor(l1Signer: Signer, event: ClassicL2ToL1TransactionEvent['args'], outboxAddress: string);
    constructor(l1Signer: Signer, event: L2ToL1TransactionEvent, outboxAddress?: string);
    /**
     * Executes the L2ToL1Message on L1.
     * Will throw an error if the outbox entry has not been created, which happens when the
     * corresponding assertion is confirmed.
     * @returns
     */
    execute(l2Provider: Provider, overrides?: Overrides): Promise<ContractTransaction>;
}
