/*
 * Copyright 2021, Offchain Labs, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
/* eslint-env node */
'use strict';
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.L2ToL1MessageWriter = exports.L2ToL1MessageReader = exports.L2ToL1Message = exports.L2ToL1MessageStatus = void 0;
const ethers_1 = require("ethers");
const errors_1 = require("../dataEntities/errors");
const signerOrProvider_1 = require("../dataEntities/signerOrProvider");
const classic = __importStar(require("@arbitrum/sdk-classic"));
const nitro = __importStar(require("@arbitrum/sdk-nitro"));
const migration_types_1 = require("../utils/migration_types");
const utils_1 = require("ethers/lib/utils");
const constants_1 = require("../dataEntities/constants");
var L2ToL1MessageStatus;
(function (L2ToL1MessageStatus) {
    /**
     * ArbSys.sendTxToL1 called, but assertion not yet confirmed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["UNCONFIRMED"] = 1] = "UNCONFIRMED";
    /**
     * Assertion for outgoing message confirmed, but message not yet executed
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["CONFIRMED"] = 2] = "CONFIRMED";
    /**
     * Outgoing message executed (terminal state)
     */
    L2ToL1MessageStatus[L2ToL1MessageStatus["EXECUTED"] = 3] = "EXECUTED";
})(L2ToL1MessageStatus = exports.L2ToL1MessageStatus || (exports.L2ToL1MessageStatus = {}));
/**
 * Base functionality for L2->L1 messages
 */
class L2ToL1Message {
    isClassic(e) {
        return !!e.indexInBatch;
    }
    static fromEvent(l1SignerOrProvider, event, outboxAddress) {
        return signerOrProvider_1.SignerProviderUtils.isSigner(l1SignerOrProvider)
            ? new L2ToL1MessageWriter(l1SignerOrProvider, event, outboxAddress)
            : new L2ToL1MessageReader(l1SignerOrProvider, event, outboxAddress);
    }
    /**
     * Get event logs for L2ToL1 transactions.
     * @param l2Provider
     * @param filter Block range filter
     * @param positionOrBatchNumber The batchnumber indexed field was removed in nitro and a position indexed field was added.
     * For pre-nitro events the value passed in here will be used to find events with the same batchnumber.
     * For post nitro events it will be used to find events with the same position.
     * @param destination The L1 destination of the L2ToL1 message
     * @param hashOrUniqueId The uniqueId indexed field was removed in nitro and a hash indexed field was added.
     * For pre-nitro events the value passed in here will be used to find events with the same uniqueId.
     * For post nitro events it will be used to find events with the same hash.
     * @param indexInBatch The index in the batch, only valid for pre-nitro events. This parameter is ignored post-nitro
     * @returns Any classic and nitro events that match the provided filters.
     */
    static async getEventLogs(l2Provider, filter, positionOrBatchNumber, destination, hashOrUniqueId, indexInBatch) {
        return (await Promise.all([
            classic.L2ToL1Message.getL2ToL1MessageLogs(l2Provider, filter, positionOrBatchNumber, destination, hashOrUniqueId, indexInBatch),
            nitro.L2ToL1Message.getL2ToL1Events(l2Provider, filter, positionOrBatchNumber, destination, hashOrUniqueId),
        ])).flat(1);
    }
}
exports.L2ToL1Message = L2ToL1Message;
/**
 * Provides read-only access for l2-to-l1-messages
 */
class L2ToL1MessageReader extends L2ToL1Message {
    constructor(l1Provider, event, outboxAddress) {
        super();
        this.l1Provider = l1Provider;
        this.outboxAddress = outboxAddress;
        if (this.isClassic(event)) {
            if (!outboxAddress)
                throw new errors_1.ArbSdkError('No outbox address supplied for classic L2ToL1Message.');
            this.classicReader = new classic.L2ToL1MessageReader(l1Provider, outboxAddress, event.batchNumber, event.indexInBatch);
        }
        else {
            this.nitroReader = new nitro.L2ToL1MessageReader(l1Provider, event);
        }
    }
    async tryGetClassicProof(l2Provider) {
        if (!this.classicReader)
            throw new errors_1.ArbSdkError('Trying get classic proof for empty classic reader.');
        // If we're on the nitro node but need a classic proof we'll need
        // call a different function as it's been renamed to 'legacy'
        if (await (0, migration_types_1.isNitroL2)(l2Provider)) {
            const iNodeInterface = new utils_1.Interface('function legacyLookupMessageBatchProof(uint256 batchNum, uint64 index) external view returns (bytes32[] memory proof, uint256 path, address l2Sender, address l1Dest, uint256 l2Block, uint256 l1Block, uint256 timestamp, uint256 amount, bytes memory calldataForL1);');
            const nodeInterface = new ethers_1.Contract(constants_1.NODE_INTERFACE_ADDRESS, iNodeInterface, l2Provider);
            try {
                return nodeInterface.functions['legacyLookupMessageBatchProof'](this.classicReader.batchNumber, this.classicReader.indexInBatch);
            }
            catch (e) {
                const expectedError = "batch doesn't exist";
                const err = e;
                const actualError = err && (err.message || (err.error && err.error.message));
                if (actualError.includes(expectedError))
                    return null;
                else
                    throw e;
            }
        }
        else {
            return await this.classicReader.tryGetProof(l2Provider);
        }
    }
    async getOutboxProof(l2Provider) {
        return this.nitroReader
            ? this.nitroReader.getOutboxProof(l2Provider)
            : this.tryGetClassicProof(l2Provider);
    }
    /**
     * Get the status of this message
     * In order to check if the message has been executed proof info must be provided.
     * @returns
     */
    async status(l2Provider) {
        // can we create an l2tol1message here, we need to - the constructor is what we need
        if (this.nitroReader)
            return this.nitroReader.status(l2Provider);
        else {
            const proof = this.classicProof || (await this.tryGetClassicProof(l2Provider));
            if (proof && !this.classicProof)
                this.classicProof = proof;
            const status = await this.classicReader.status(proof);
            return (0, migration_types_1.convertL2ToL1Status)(status);
        }
    }
    /**
     * Waits until the outbox entry has been created, and will not return until it has been.
     * WARNING: Outbox entries are only created when the corresponding node is confirmed. Which
     * can take 1 week+, so waiting here could be a very long operation.
     * @param retryDelay
     * @returns
     */
    async waitUntilReadyToExecute(l2Provider, retryDelay = 500) {
        if (this.nitroReader)
            return this.nitroReader.waitUntilReadyToExecute(l2Provider, retryDelay);
        else
            return this.classicReader.waitUntilOutboxEntryCreated(retryDelay);
    }
    /**
     * Estimates the L1 block number in which this L2 to L1 tx will be available for execution.
     * If the message can or already has been executed, this returns null
     * @param l2Provider
     * @returns expected L1 block number where the L2 to L1 message will be executable. Returns null if the message can or already has been executed
     */
    async getFirstExecutableBlock(l2Provider) {
        if (this.nitroReader)
            return this.nitroReader.getFirstExecutableBlock(l2Provider);
        else
            return this.classicReader.getFirstExecutableBlock(l2Provider);
    }
}
exports.L2ToL1MessageReader = L2ToL1MessageReader;
/**
 * Provides read and write access for l2-to-l1-messages
 */
class L2ToL1MessageWriter extends L2ToL1MessageReader {
    constructor(l1Signer, event, outboxAddress) {
        super(l1Signer.provider, event, outboxAddress);
        if (this.isClassic(event)) {
            if (!outboxAddress)
                throw new errors_1.ArbSdkError('No outbox address supplied for classic L2ToL1Message.');
            this.classicWriter = new classic.L2ToL1MessageWriter(l1Signer, outboxAddress, event.batchNumber, event.indexInBatch);
        }
        else {
            this.nitroWriter = new nitro.L2ToL1MessageWriter(l1Signer, event);
        }
    }
    /**
     * Executes the L2ToL1Message on L1.
     * Will throw an error if the outbox entry has not been created, which happens when the
     * corresponding assertion is confirmed.
     * @returns
     */
    async execute(l2Provider, overrides) {
        if (this.nitroWriter)
            return this.nitroWriter.execute(l2Provider, overrides);
        else {
            const proof = this.classicProof || (await this.tryGetClassicProof(l2Provider));
            if (proof === null)
                throw new errors_1.ArbSdkError('Unexpected missing proof');
            if (!this.classicProof)
                this.classicProof = proof;
            return await this.classicWriter.execute(proof);
        }
    }
}
exports.L2ToL1MessageWriter = L2ToL1MessageWriter;
