import { TransactionReceipt } from '@ethersproject/providers';
import { Log } from '@ethersproject/abstract-provider';
import { ContractTransaction } from '@ethersproject/contracts';
import { BigNumber } from '@ethersproject/bignumber';
import { Provider } from '@ethersproject/abstract-provider';
import { L1ToL2MessageWaitResult } from './L1ToL2Message';
import { DepositInitiatedEvent } from '../abi/L1ERC20Gateway';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { EthDepositMessageWaitResult as NitroEthDepositMessageWaitResult } from '@arbitrum/sdk-nitro/dist/lib/message/L1ToL2Message';
import { IL1ToL2MessageReaderOrWriter, EthDepositMessage } from '../utils/migration_types';
export interface L1ContractTransaction<TReceipt extends L1TransactionReceipt = L1TransactionReceipt> extends ContractTransaction {
    wait(confirmations?: number): Promise<TReceipt>;
}
export declare type L1EthDepositTransaction = L1ContractTransaction<L1EthDepositTransactionReceipt>;
export declare type L1ContractCallTransaction = L1ContractTransaction<L1ContractCallTransactionReceipt>;
export declare class L1TransactionReceipt implements TransactionReceipt {
    readonly to: string;
    readonly from: string;
    readonly contractAddress: string;
    readonly transactionIndex: number;
    readonly root?: string;
    readonly gasUsed: BigNumber;
    readonly logsBloom: string;
    readonly blockHash: string;
    readonly transactionHash: string;
    readonly logs: Array<Log>;
    readonly blockNumber: number;
    readonly confirmations: number;
    readonly cumulativeGasUsed: BigNumber;
    readonly effectiveGasPrice: BigNumber;
    readonly byzantium: boolean;
    readonly type: number;
    readonly status?: number;
    private readonly classicReceipt;
    private readonly nitroReceipt;
    constructor(tx: TransactionReceipt);
    /**
     * Get any l1tol2 messages created by this transaction
     * @param l2SignerOrProvider
     */
    getL1ToL2Messages<T extends SignerOrProvider>(l2SignerOrProvider: T): Promise<IL1ToL2MessageReaderOrWriter<T>[]>;
    /**
     * Gets a single l1ToL2Message
     * If the messageIndex is supplied the message at that index will be returned.
     * If no messageIndex is supplied a message will be returned if this transaction only created one message
     * All other cases throw an error
     * @param l2SignerOrProvider
     */
    getL1ToL2Message<T extends SignerOrProvider>(l2SignerOrProvider: T, messageNumberIndex?: number): Promise<IL1ToL2MessageReaderOrWriter<T>>;
    /**
     * Get any token deposit events created by this transaction
     * @returns
     */
    getTokenDepositEvents(): DepositInitiatedEvent['args'][];
    /**
     * Replaces the wait function with one that returns an L1TransactionReceipt
     * @param contractTransaction
     * @returns
     */
    static monkeyPatchWait: (contractTransaction: ContractTransaction) => L1ContractTransaction;
    /**
     * Replaces the wait function with one that returns an L1EthDepositTransactionReceipt
     * @param contractTransaction
     * @returns
     */
    static monkeyPatchEthDepositWait: (contractTransaction: ContractTransaction) => L1EthDepositTransaction;
    /**
     * Replaces the wait function with one that returns an L1ContractCallTransactionReceipt
     * @param contractTransaction
     * @returns
     */
    static monkeyPatchContractCallWait: (contractTransaction: ContractTransaction) => L1ContractCallTransaction;
}
/**
 * An L1TransactionReceipt with additional functionality that only exists
 * if the transaction created a single eth deposit.
 */
export declare class L1EthDepositTransactionReceipt extends L1TransactionReceipt {
    /**
     * Wait for the funds to arrive on L2
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains `complete`, a `status`, the L1ToL2Message and optionally the `l2TxReceipt`
     * If `complete` is true then this message is in the terminal state.
     * For eth deposits complete this is when the status is FUNDS_DEPOSITED, EXPIRED or REDEEMED.
     */
    waitForL2(l2Provider: Provider, confirmations?: number, timeout?: number): Promise<{
        complete: boolean;
        message: EthDepositMessage;
    } & NitroEthDepositMessageWaitResult>;
}
/**
 * An L1TransactionReceipt with additional functionality that only exists
 * if the transaction created a single call to an L2 contract - this includes
 * token deposits.
 */
export declare class L1ContractCallTransactionReceipt extends L1TransactionReceipt {
    /**
     * Wait for the transaction to arrive and be executed on L2
     * @param confirmations Amount of confirmations the retryable ticket and the auto redeem receipt should have
     * @param timeout Amount of time to wait for the retryable ticket to be created
     * Defaults to 15 minutes, as by this time all transactions are expected to be included on L2. Throws on timeout.
     * @returns The wait result contains `complete`, a `status`, an L1ToL2Message and optionally the `l2TxReceipt`.
     * If `complete` is true then this message is in the terminal state.
     * For contract calls this is true only if the status is REDEEMED.
     */
    waitForL2<T extends SignerOrProvider>(l2SignerOrProvider: T, confirmations?: number, timeout?: number): Promise<{
        complete: boolean;
        message: IL1ToL2MessageReaderOrWriter<T>;
    } & L1ToL2MessageWaitResult>;
}
