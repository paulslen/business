import { TransactionReceipt } from '@ethersproject/providers';
import { BigNumber } from '@ethersproject/bignumber';
import { Log, Provider } from '@ethersproject/abstract-provider';
import { ContractTransaction, providers } from 'ethers';
import { SignerOrProvider } from '../dataEntities/signerOrProvider';
import { L2ToL1TransactionEvent } from './L2ToL1Message';
import { IL2ToL1MessageReaderOrWriter } from '../utils/migration_types';
export interface L2ContractTransaction extends ContractTransaction {
    wait(confirmations?: number): Promise<L2TransactionReceipt>;
}
export interface RedeemTransaction extends L2ContractTransaction {
    waitForRedeem: () => Promise<TransactionReceipt>;
}
export declare class L2TransactionReceipt implements TransactionReceipt {
    readonly to: string;
    readonly from: string;
    readonly contractAddress: string;
    readonly transactionIndex: number;
    readonly root?: string;
    readonly gasUsed: BigNumber;
    readonly logsBloom: string;
    readonly blockHash: string;
    readonly transactionHash: string;
    readonly logs: Array<Log>;
    readonly blockNumber: number;
    readonly confirmations: number;
    readonly cumulativeGasUsed: BigNumber;
    readonly effectiveGasPrice: BigNumber;
    readonly byzantium: boolean;
    readonly type: number;
    readonly status?: number;
    private readonly classicReceipt;
    private readonly nitroReceipt;
    constructor(tx: TransactionReceipt);
    /**
     * Get an L2ToL1Transaction events created by this transaction
     * @returns
     */
    getL2ToL1Events(): L2ToL1TransactionEvent[];
    private isClassic;
    /**
     * Get any l2-to-l1-messages created by this transaction
     * @param l2SignerOrProvider
     */
    getL2ToL1Messages<T extends SignerOrProvider>(l1SignerOrProvider: T, l2Provider: Provider): Promise<IL2ToL1MessageReaderOrWriter<T>[]>;
    /**
     * Whether the data associated with this transaction has been
     * made available on L1
     * @param l2Provider
     * @param confirmations The number of confirmations on the batch before data is to be considered available
     * @returns
     */
    isDataAvailable(l2Provider: providers.JsonRpcProvider, l1Provider: providers.JsonRpcProvider, confirmations?: number): Promise<boolean>;
    /**
     * Replaces the wait function with one that returns an L2TransactionReceipt
     * @param contractTransaction
     * @returns
     */
    static monkeyPatchWait: (contractTransaction: ContractTransaction) => L2ContractTransaction;
}
